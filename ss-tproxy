#!/bin/bash

PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# 除了主脚本，其他文件都放这个目录，此值可被命令行参数覆盖
base_dir='/etc/ss-tproxy' # 同时也是工作目录
config_file='ss-tproxy.conf' # 可被命令行参数覆盖

# 已存在的函数和变量尽量别改名/删除，因为可能被 ss-tproxy.conf 引用(如钩子函数)
# 由于需要执行 iptables、策略路由、内核参数 等特权操作，脚本必须以 root 权限执行

font_bold() {
    printf "\e[1m$*\e[0m"
}

color_red() {
    printf "\e[35m$*\e[0m"
}

color_green() {
    printf "\e[32m$*\e[0m"
}

color_yellow() {
    printf "\e[31m$*\e[0m"
}

# 打印错误消息，并退出脚本
log_error() {
    echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2
    exit 1
}

is_func() {
    [ "$(type -t $1)" = 'function' ]
}

# 使用数值0和1做布尔值最好，但由于历史原因，没法改了
is_true() {
    [ "$1" = 'true' ]
}

is_false() {
    ! is_true "$1"
}

# str substr
str_find() {
    [[ "$1" == *"$2"* ]]
}

file_is_exists() {
    [ -f "$1" ]
}

file_required() {
    file_is_exists "$1" || log_error "file not found: $1"
}

list_ext_ipv4() {
    grep '^-' "$1" | cut -c2-
}

list_ext_ipv6() {
    grep '^~' "$1" | cut -c2-
}

list_ext_domain() {
    grep '^@' "$1" | cut -c2-
}

command_path() {
    command -v "$1"
}

command_is_exists() {
    command -v "$1" &>/dev/null
}

command_required() {
    command_is_exists "$1" || log_error "command not found: $1"
}

# group command
set_command_group() {
    local group="$1"
    local path="$(command_path "$2")"
    chgrp "$group" "$path" || log_error "chgrp failed: group=$group path=$path"
    chmod g+xs "$path"
}

process_is_running() {
    kill -0 "$1" &>/dev/null
}

tcp_port_is_exists() {
    $netstat -lnpt | grep -q ":$1[[:blank:]]"
}

udp_port_is_exists() {
    $netstat -anpu | grep -q ":$1[[:blank:]]"
}

ss_tproxy_is_started() {
    iptables  -t mangle -S SSTP_OUTPUT &>/dev/null ||
    iptables  -t nat    -S SSTP_OUTPUT &>/dev/null ||
    ip6tables -t mangle -S SSTP_OUTPUT &>/dev/null ||
    ip6tables -t nat    -S SSTP_OUTPUT &>/dev/null ||
    ip -4 rule 2>/dev/null | grep -q "lookup $ipts_rt_tab" ||
    ip -6 rule 2>/dev/null | grep -q "lookup $ipts_rt_tab" ||
    ip -4 route show table $ipts_rt_tab 2>/dev/null | grep -q '^' ||
    ip -6 route show table $ipts_rt_tab 2>/dev/null | grep -q '^'
}

is_ipv4_ipts() {
    [ "$1" = 'iptables' ]
}

is_ipv6_ipts() {
    [ "$1" = 'ip6tables' ]
}

# $ipts table chain
chain_is_exists() {
    local table="$2" chain="$3"
    $1 -t $table -S $chain &>/dev/null
}

# 先判断chain是否存在
# $ipts table chain
chain_is_empty() {
    local table="$2" chain="$3"
    [ $($1 -t $table -S $chain | wc -l) -le 1 ]
}

is_global_mode() {
    [ "$mode" = 'global' ]
}

is_gfwlist_mode() {
    [ "$mode" = 'gfwlist' ]
}

is_chnroute_mode() {
    [ "$mode" = 'chnroute' ]
}

is_built_in_dns() {
    is_false "$dns_custom"
}

is_proxy_other() {
    is_false "$selfonly"
}

is_enabled_ipv4() {
    is_true "$ipv4"
}

is_enabled_ipv6() {
    is_true "$ipv6"
}

is_enabled_udp() {
    is_false "$tcponly"
}

is_enabled_chinadns() {
    is_chnroute_mode || { is_gfwlist_mode && is_true "$chinadns_for_gfwlist" && command_is_exists 'chinadns-ng'; }
}

is_enabled_dns2tcp() {
    case "$dns2tcp_enable" in
        auto)
            ! is_enabled_udp
            ;;
        true)
            true
            ;;
        false)
            is_built_in_dns && log_error "can't disable dns2tcp when using built-in dns"
            false
            ;;
        *)
            log_error "invalid config value for dns2tcp_enable: '$dns2tcp_enable'"
            ;;
    esac
}

is_need_iproute() {
    is_true "$tproxy" || is_enabled_udp
}

# ip#port
get_ip_from_addr() {
    local addr="$1"
    echo "${addr%#*}"
}

# ip#port
get_port_from_addr() {
    local addr="$1"
    echo "${addr#*#}"
}

get_directdns_ip() {
    get_ip_from_addr "$dns_direct"
}

get_directdns6_ip() {
    get_ip_from_addr "$dns_direct6"
}

get_directdns_port() {
    get_port_from_addr "$dns_direct"
}

get_directdns6_port() {
    get_port_from_addr "$dns_direct6"
}

get_remotedns_ip() {
    get_ip_from_addr "$dns_remote"
}

get_remotedns6_ip() {
    get_ip_from_addr "$dns_remote6"
}

get_remotedns_port() {
    get_port_from_addr "$dns_remote"
}

get_remotedns6_port() {
    get_port_from_addr "$dns_remote6"
}

load_pidfile() {
    file_is_exists /run/ss-tproxy.pid && source /run/ss-tproxy.pid
}

save_pidfile() {
    {
        echo "pid_dnsmasq=$pid_dnsmasq"
        echo "pid_chinadns=$pid_chinadns"
        echo "pid_dns2tcp4=$pid_dns2tcp4"
        echo "pid_dns2tcp6=$pid_dns2tcp6"
    } >/run/ss-tproxy.pid
}

delete_pidfile() {
    rm -f /run/ss-tproxy.pid &>/dev/null
}

load_config() {
    file_required $config_file
    source $config_file "${arg_list[@]}" || log_error "$config_file load failed, exit-code: $?"
    for override in "${override_list[@]}"; do eval "$override"; done
}

check_config() {
    { ! is_enabled_ipv4 && ! is_enabled_ipv6; } &&
        log_error "both ipv4 and ipv6 are disabled, nothing to do"

    if is_global_mode; then
        # 白名单
        file_required ignlist.ext
    elif is_gfwlist_mode; then
        # 黑名单
        file_required gfwlist.txt
        file_required gfwlist.ext
    elif is_chnroute_mode; then
        # 白名单 + 黑名单(优先)
        file_required ignlist.ext
        file_required chnlist.txt
        file_required chnroute.txt
        file_required chnroute6.txt
        file_required gfwlist.txt
        file_required gfwlist.ext
    else
        log_error "invalid config value for mode: '$mode'"
    fi

    is_need_iproute && command_required 'ip'

    command_required 'ipset'
    is_enabled_ipv4 && command_required 'iptables'
    is_enabled_ipv6 && command_required 'ip6tables'

    is_built_in_dns && {
        command_required 'dnsmasq'
        set_command_group "$dns_procgroup" 'dnsmasq'

        is_enabled_chinadns && {
            command_required 'chinadns-ng'
            set_command_group "$dns_procgroup" 'chinadns-ng'
        }
    }

    is_enabled_dns2tcp && {
        command_required 'dns2tcp'
        set_command_group "$dns_procgroup" 'dns2tcp'
    }

    case "$opts_ss_netstat" in
        auto)
            if command_is_exists 'ss'; then
                netstat='ss'
            elif command_is_exists 'netstat'; then
                netstat='netstat'
            else
                log_error "command not found: ss/netstat"
            fi
            ;;
        ss)
            command_required 'ss'
            netstat='ss'
            ;;
        netstat)
            command_required 'netstat'
            netstat='netstat'
            ;;
        *)
            log_error "invalid config value for opts_ss_netstat: '$opts_ss_netstat'"
            ;;
    esac
}

# url filename
update_domain_list() {
    command_required 'curl'

    local url="$1" filename="$2"

    local data # 声明和赋值必须分开，不然错误码会丢失
    data="$(curl -4sSkL "$url" | grep -v -e '^[[:space:]]*$' -e '^[[:space:]]*#')" ||
        log_error "download failed: $url (exit-code: $?)"

    if head -n1 <<<"$data" | grep -q /; then
        # server=/域名后缀/dns_ip
        echo "$data" | awk -F/ '{print $2}' | sort | uniq >$filename
    else
        # 纯域名后缀
        echo "$data" | sort | uniq >$filename
    fi
}

update_gfwlist() {
    update_domain_list "$url_gfwlist" gfwlist.txt
}

update_chnlist() {
    update_domain_list "$url_chnlist" chnlist.txt
}

update_chnroute() {
    command_required 'curl'

    local data # 声明和赋值必须分开，不然错误码会丢失
    data="$(curl -4sSkL "$url_chnroute" | grep CN)" ||
        log_error "download failed: $url_chnroute (exit-code: $?)"

    awk -F'|' '/ipv4/ {printf("%s/%d\n", $4, 32-log($5)/log(2))}' <<<"$data" >chnroute.txt
    awk -F'|' '/ipv6/ {printf("%s/%d\n", $4, $5)}' <<<"$data" >chnroute6.txt
}

# is_blacklist <domain_list
get_dnsconf() {
    local server server6
    local setname setname6
    local default default6

    if (($1)); then
        # domain_list是黑名单
        server="$dns_remote"
        server6="$dns_remote6"
        setname="sstp_black"
        setname6="sstp_black6"
        default="$dns_direct"
        default6="$dns_direct6"
    else
        # domain_list是白名单
        server="$dns_direct"
        server6="$dns_direct6"
        setname="sstp_white"
        setname6="sstp_white6"
        default="$dns_remote"
        default6="$dns_remote6"
    fi

    is_enabled_ipv4 && echo "server = $default"
    is_enabled_ipv6 && echo "server = $default6"

    local v4=$(is_enabled_ipv4 && echo 1 || echo 0)
    local v6=$(is_enabled_ipv6 && echo 1 || echo 0)

    # 避免使用 read，会触发过多系统调用，太慢
    awk -F'\n' \
        -v v4=$v4 \
        -v v6=$v6 \
        -v server=$server \
        -v server6=$server6 \
        -v setname=$setname \
        -v setname6=$setname6 \
        '{
            if (v4 && v6) {
                printf("server = /%s/%s\n", $0, server)
                printf("server = /%s/%s\n", $0, server6)
                printf("ipset = /%s/%s,%s\n", $0, setname, setname6)
            } else if (v4) {
                printf("server = /%s/%s\n", $0, server)
                printf("ipset = /%s/%s\n", $0, setname)
            } else {
                printf("server = /%s/%s\n", $0, server6)
                printf("ipset = /%s/%s\n", $0, setname6)
            }
        }'
}

get_global_dnsconf() {
    list_ext_domain ignlist.ext | get_dnsconf 0 
}

get_gfwlist_dnsconf() {
    if is_enabled_chinadns; then
        echo "server = 127.0.0.1#$chinadns_bind_port"
    else
        { cat gfwlist.txt; list_ext_domain gfwlist.ext; } | get_dnsconf 1
    fi
}

get_chnroute_dnsconf() {
    echo "server = 127.0.0.1#$chinadns_bind_port"
}

start_chinadns() {
    local args="$chinadns_extra_options -b 127.0.0.1 -l $chinadns_bind_port"

    if is_enabled_ipv4 && is_enabled_ipv6; then
        args+=" -c $dns_direct,$dns_direct6"
        args+=" -t $dns_remote,$dns_remote6"
    elif is_enabled_ipv4; then
        args+=" -c $dns_direct"
        args+=" -t $dns_remote"
    else
        args+=" -c $dns_direct6"
        args+=" -t $dns_remote6"
    fi

    is_true "$chinadns_verbose" && args+=' -v'

    if is_gfwlist_mode; then
        pid_chinadns=$(
            chinadns-ng \
            $args \
            -g gfwlist.txt,<(list_ext_domain gfwlist.ext) \
            -d chn \
            -A sstp_black,sstp_black6 \
            </dev/null &>>$chinadns_logfile &
            echo $!
        )
    else # chnroute
        pid_chinadns=$(
            chinadns-ng \
            $args \
            -g gfwlist.txt,<(list_ext_domain gfwlist.ext) \
            -m chnlist.txt,<(list_ext_domain ignlist.ext) \
            $(is_true "$chinadns_chnlist_first" && echo '-M') \
            -4 sstp_white \
            -6 sstp_white6 \
            -a \
            -A sstp_black,sstp_black6 \
            </dev/null &>>$chinadns_logfile &
            echo $!
        )
    fi
}

# is_ipv4
# 此函数需要在subshell中执行
start_dns2tcp() {
    local args
    if (($1)); then
        args="-L 127.0.0.1#$dns2tcp_bind_port -R $dns_remote"
    else
        args="-L       ::1#$dns2tcp_bind_port -R $dns_remote6 -6"
    fi
    is_true "$dns2tcp_verbose" && args+=" -v"
    dns2tcp $dns2tcp_extra_options $args </dev/null &>>$dns2tcp_logfile &
    echo $!
}

start_dnsserver() {
    if is_built_in_dns; then
        is_enabled_chinadns && start_chinadns

        pid_dnsmasq=$(
            {
                echo "port = $dns_mainport"
                echo "group = $dns_procgroup"
                is_true "$dnsmasq_log_enable" && echo 'log-queries'
                echo "log-facility = $dnsmasq_log_file"
                echo "log-async = 20"
                echo "domain-needed"
                echo "no-resolv"
                echo "no-negcache"
                echo "cache-size = $dnsmasq_cache_size"
                if ((dnsmasq_cache_time_min)) && dnsmasq --help | grep -q min-cache-ttl; then
                    echo "min-cache-ttl = $dnsmasq_cache_time_min"
                fi
                echo "dns-forward-max = $dnsmasq_query_maxcnt"
                for arg in "${dnsmasq_conf_dir[@]}"; do echo "conf-dir = $arg"; done
                for arg in "${dnsmasq_conf_file[@]}"; do echo "conf-file = $arg"; done
                for arg in "${dnsmasq_conf_string[@]}"; do echo "$arg"; done
                if is_global_mode; then
                    get_global_dnsconf
                elif is_gfwlist_mode; then
                    get_gfwlist_dnsconf
                elif is_chnroute_mode; then
                    get_chnroute_dnsconf
                fi
            } | dnsmasq --keep-in-foreground --conf-file=- &
            echo $!
        )
    fi

    if is_enabled_dns2tcp; then
        is_enabled_ipv4 && pid_dns2tcp4=$(start_dns2tcp 1)
        is_enabled_ipv6 && pid_dns2tcp6=$(start_dns2tcp 0)
    fi

    save_pidfile
}

stop_dnsserver() {
    kill -9 $pid_dnsmasq  &>/dev/null
    kill -9 $pid_chinadns &>/dev/null
    kill -9 $pid_dns2tcp4 &>/dev/null
    kill -9 $pid_dns2tcp6 &>/dev/null
    delete_pidfile
}

flush_dnscache() {
    ! is_built_in_dns && return
    ! ss_tproxy_is_started && return
    kill -HUP "$pid_dnsmasq"
}

# 4/6 key=val
sysctl_all_iface() {
    for path in /proc/sys/net/ipv$1/conf/*; do
        sysctl -wq ${path#/proc/sys/}/$2
    done
}

set_kernel_param() {
    # 允许ip转发，充当网关
    is_enabled_ipv4 && sysctl -wq net.ipv4.ip_forward=1
    is_enabled_ipv6 && sysctl_all_iface 6 forwarding=1

    # 允许路由loopback地址，如果不开启，外部数据包将无法dnat至127.0.0.1
    sysctl_all_iface 4 route_localnet=1

    # 禁止发送icmp重定向包，防止内网机在ping的时候收到重定向消息("旁路由"拓扑)
    sysctl_all_iface 4 send_redirects=0
}

# 进程启动失败将退出脚本
start_proxyproc() {
    eval "$proxy_startcmd" || log_error "failed to start local proxy process, exit-code: $?"
}

stop_proxyproc() {
    eval "$proxy_stopcmd" &>/dev/null
}

# setname <ip_list
init_ipset() {
    ipset create $1 hash:net family $(str_find $1 6 && echo inet6 || echo inet)
    sed "s/^/add $1 /" | ipset -! restore
}

# dns和iptables都需要ipset，为防止dns组件报错(A/AAAA)，v4和v6集合将始终创建
start_ipset() {
    if is_global_mode; then
        { list_ext_ipv4 ignlist.ext; get_directdns_ip;  } | init_ipset sstp_white
        { list_ext_ipv6 ignlist.ext; get_directdns6_ip; } | init_ipset sstp_white6
    elif is_gfwlist_mode; then
        { list_ext_ipv4 gfwlist.ext; get_remotedns_ip;  } | init_ipset sstp_black
        { list_ext_ipv6 gfwlist.ext; get_remotedns6_ip; } | init_ipset sstp_black6
    elif is_chnroute_mode; then
        { list_ext_ipv4 ignlist.ext; get_directdns_ip;  cat chnroute.txt;  } | init_ipset sstp_white
        { list_ext_ipv6 ignlist.ext; get_directdns6_ip; cat chnroute6.txt; } | init_ipset sstp_white6
        { list_ext_ipv4 gfwlist.ext; get_remotedns_ip;  } | init_ipset sstp_black
        { list_ext_ipv6 gfwlist.ext; get_remotedns6_ip; } | init_ipset sstp_black6
    fi
}

# stop就清空，如果只是换节点或重启代理，不要通过ss-tproxy进行，请直接操作代理进程
flush_ipset() {
    ipset -! destroy sstp_white
    ipset -! destroy sstp_white6
    ipset -! destroy sstp_black
    ipset -! destroy sstp_black6
}

add_reddns_rule() {
    is_false "$ipts_reddns_onstop" && return

    local direct_dns_ip direct_dns_ipx direct_dns_port

    if is_ipv4_ipts $1; then
        direct_dns_ip="$(get_directdns_ip)"
        direct_dns_ipx="$(get_directdns_ip)"
        direct_dns_port="$(get_directdns_port)"
    else
        direct_dns_ip="$(get_directdns6_ip)"
        direct_dns_ipx="[$(get_directdns6_ip)]"
        direct_dns_port="$(get_directdns6_port)"
    fi

    $1 -t nat -N SSTP_PREROUTING  &>/dev/null
    $1 -t nat -N SSTP_POSTROUTING &>/dev/null

    $1 -t nat -A SSTP_PREROUTING \
        -p udp \
        -m udp --dport 53 \
        -m addrtype ! --src-type LOCAL --dst-type LOCAL \
        -j DNAT --to-destination $direct_dns_ipx:$direct_dns_port

    $1 -t nat -A SSTP_POSTROUTING \
        -d $direct_dns_ip \
        -p udp \
        -m udp --dport $direct_dns_port \
        -m addrtype ! --src-type LOCAL \
        -j MASQUERADE
}

add_snat_rule() {
    if is_ipv4_ipts $1; then
        is_false "$ipts_set_snat" && return
    else
        is_false "$ipts_set_snat6" && return
    fi

    $1 -t nat -N SSTP_POSTROUTING &>/dev/null

    $1 -t nat -A SSTP_POSTROUTING \
        -m owner ! --socket-exists \
        -m conntrack --ctstate NEW \
        -m conntrack ! --ctstate SNAT,DNAT \
        -j MASQUERADE
}

# $ipts table 预定义链
add_sstp_chain() {
    local table="$2" chain="$3"
    if chain_is_exists $1 $table SSTP_$chain; then
        $1 -t $table -A $chain -j SSTP_$chain
    fi
}

_add_stoprule() {
    add_reddns_rule $1
    add_snat_rule $1

    add_sstp_chain $1 nat PREROUTING
    add_sstp_chain $1 nat POSTROUTING
}

add_stoprule() {
    ! is_proxy_other && return

    is_enabled_ipv4 && _add_stoprule "iptables"
    is_enabled_ipv6 && _add_stoprule "ip6tables"
}

_flush_stoprule() {
    $1 -t nat -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    $1 -t nat -D POSTROUTING -j SSTP_POSTROUTING &>/dev/null

    $1 -t nat -F SSTP_PREROUTING  &>/dev/null
    $1 -t nat -X SSTP_PREROUTING  &>/dev/null

    $1 -t nat -F SSTP_POSTROUTING &>/dev/null
    $1 -t nat -X SSTP_POSTROUTING &>/dev/null
}

flush_stoprule() {
    ss_tproxy_is_started && return

    # 不做判断，防止相关配置改动导致残留
    _flush_stoprule "iptables"
    _flush_stoprule "ip6tables"
}

_start_iproute() {
    local family="$1"

    # 将请求方向的包路由至本地(从而进入prerouting链)
    ip $family route add local default dev $ipts_if_lo table $ipts_rt_tab

    # https://github.com/zfl9/ss-tproxy/pull/186
    # https://man7.org/linux/man-pages/man8/ip-rule.8.html
    # https://man7.org/linux/man-pages/man7/rtnetlink.7.html
    # https://stackoverflow.com/questions/10259266/what-does-proto-kernel-means-in-unix-routing-table
    if ip rule help 2>&1 | grep -Fwq protocol; then
        ip $family rule add fwmark $ipts_rt_mark table $ipts_rt_tab protocol static
    else
        ip $family rule add fwmark $ipts_rt_mark table $ipts_rt_tab
    fi
}

start_iproute() {
    ! is_need_iproute && return

    is_enabled_ipv4 && _start_iproute -4
    is_enabled_ipv6 && _start_iproute -6
}

_flush_iproute() {
    while ip $1 rule del table $ipts_rt_tab &>/dev/null; do true; done
    ip $1 route flush table $ipts_rt_tab &>/dev/null
}

flush_iproute() {
    # 不做判断，防止相关配置改动导致残留
    _flush_iproute -4
    _flush_iproute -6
}

start_iptables_pre() {
    $1 -t mangle -N SSTP_PREROUTING
    $1 -t mangle -N SSTP_OUTPUT
    $1 -t nat    -N SSTP_PREROUTING
    $1 -t nat    -N SSTP_OUTPUT
    $1 -t nat    -N SSTP_POSTROUTING
}

start_iptables_post() {
    $1 -t mangle -A PREROUTING  -j SSTP_PREROUTING
    $1 -t mangle -A OUTPUT      -j SSTP_OUTPUT
    $1 -t nat    -A PREROUTING  -j SSTP_PREROUTING
    $1 -t nat    -A OUTPUT      -j SSTP_OUTPUT
    $1 -t nat    -A POSTROUTING -j SSTP_POSTROUTING
}

# local loopback_addr loopback_addrx remote_dns_ip remote_dns_port white_setname black_setname
init_iptables_param() {
    if is_ipv4_ipts $1; then
        loopback_addr="127.0.0.1"
        loopback_addrx="127.0.0.1"
        remote_dns_ip="$(get_remotedns_ip)"
        remote_dns_port="$(get_remotedns_port)"
        white_setname="sstp_white"
        black_setname="sstp_black"
    else
        loopback_addr="::1"
        loopback_addrx="[::1]"
        remote_dns_ip="$(get_remotedns6_ip)"
        remote_dns_port="$(get_remotedns6_port)"
        white_setname="sstp_white6"
        black_setname="sstp_black6"
    fi
}

get_dst_port_match() {
    [ "$ipts_proxy_dst_port" ] &&
        echo "-m multiport --dports $ipts_proxy_dst_port"
}

# tproxy: mangle表 (tcp,udp)
# dnat:   nat表    (tcp)
# $ipts tproxy/dnat
create_sstp_rule() {
    local table action
    if [ "$2" = 'tproxy' ]; then
        table=mangle
        action="-j CONNMARK --set-mark $ipts_rt_mark"
    else
        table=nat
        action="-p tcp -j DNAT --to-destination $loopback_addrx:$proxy_tcpport"
    fi

    $1 -t $table -N SSTP_RULE
    if is_global_mode; then
        $1 -t $table -A SSTP_RULE \
            -m set ! --match-set $white_setname dst \
            $action
    elif is_gfwlist_mode; then
        $1 -t $table -A SSTP_RULE \
            -m set --match-set $black_setname dst \
            $action
    elif is_chnroute_mode; then
        # 放行白名单ip (若该ip同时也位于黑名单，则不放行)
        $1 -t $table -A SSTP_RULE \
            -m set --match-set $white_setname dst \
            -m set ! --match-set $black_setname dst \
            -j RETURN
        $1 -t $table -A SSTP_RULE \
            $action
    fi
}

# mangle表 OUTPUT/PREROUTING
do_proxy_tproxy() {
    local tcp=$(is_true "$tproxy" && echo 1 || echo 0)
    local udp=$(is_enabled_udp && echo 1 || echo 0)

    create_sstp_rule $1 tproxy

    # 放行发往本机的流量
    $1 -t mangle -A SSTP_OUTPUT \
        -m addrtype --dst-type LOCAL \
        -j RETURN

    # 放行本机代理进程
    $1 -t mangle -A SSTP_OUTPUT \
        -m owner --gid-owner $proxy_procgroup \
        -j RETURN

    # 放行本机发出的dns请求，留给nat去重定向
    ((udp)) &&
        $1 -t mangle -A SSTP_OUTPUT \
            -p udp \
            -m udp --dport 53 \
            -m addrtype --src-type LOCAL \
            -m owner ! --gid-owner $dns_procgroup \
            -j RETURN

    # 使用dns2tcp时，放行发往dns_remote的udp请求，留给nat去重定向
    ((udp)) && is_enabled_dns2tcp &&
        $1 -t mangle -A SSTP_OUTPUT \
            -d $remote_dns_ip \
            -p udp \
            -m udp --dport $remote_dns_port \
            -m addrtype --src-type LOCAL \
            -j RETURN

    # 本机传出流量 => SSTP_RULE
    # 会被路由进入lo，进入prerouting，被tproxy
    ((tcp)) &&
        $1 -t mangle -A SSTP_OUTPUT \
            -p tcp \
            -m tcp --syn \
            -m addrtype --src-type LOCAL \
            $(get_dst_port_match) \
            -j SSTP_RULE
    ((udp)) &&
        $1 -t mangle -A SSTP_OUTPUT \
            -p udp \
            -m conntrack --ctstate NEW \
            -m addrtype --src-type LOCAL \
            $(get_dst_port_match) \
            -j SSTP_RULE

    # 必定是original方向，因为reply方向的包在开头就被return了
    # 打mark是为了配合策略路由，将包路由到本地，进入prerouting
    $1 -t mangle -A SSTP_OUTPUT \
        -m connmark --mark $ipts_rt_mark \
        -j MARK --set-mark $ipts_rt_mark

    ###################### prerouting ######################

    # 放行发往本机的流量
    $1 -t mangle -A SSTP_PREROUTING \
        -m addrtype --dst-type LOCAL \
        -j RETURN

    # 处理本机传出的包，已经打过mark了，直接tproxy
    ((tcp)) &&
        $1 -t mangle -A SSTP_PREROUTING \
            -p tcp \
            -m mark --mark $ipts_rt_mark \
            -j TPROXY --on-ip $loopback_addr --on-port $proxy_tcpport
    ((udp)) &&
        $1 -t mangle -A SSTP_PREROUTING \
            -p udp \
            -m mark --mark $ipts_rt_mark \
            -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport

    # 内网传出流量 => SSTP_RULE
    # 所有发往LOCAL地址的包都会走这里，注意判定
    if is_proxy_other; then
        ((tcp)) &&
            $1 -t mangle -A SSTP_PREROUTING \
                -p tcp \
                -m tcp --syn \
                -m addrtype ! --src-type LOCAL \
                $(get_dst_port_match) \
                -j SSTP_RULE
        ((udp)) &&
            $1 -t mangle -A SSTP_PREROUTING \
                -p udp \
                -m conntrack --ctstate NEW \
                -m addrtype ! --src-type LOCAL \
                $(get_dst_port_match) \
                -j SSTP_RULE
        ((tcp)) &&
            $1 -t mangle -A SSTP_PREROUTING \
                -p tcp \
                -m connmark --mark $ipts_rt_mark \
                -j TPROXY --on-ip $loopback_addr --on-port $proxy_tcpport --tproxy-mark $ipts_rt_mark
        ((udp)) &&
            $1 -t mangle -A SSTP_PREROUTING \
                -p udp \
                -m connmark --mark $ipts_rt_mark \
                -j TPROXY --on-ip $loopback_addr --on-port $proxy_udpport --tproxy-mark $ipts_rt_mark
    fi
}

# nat表 OUTPUT/PREROUTING -p tcp
do_proxy_dnat() {
    create_sstp_rule $1 dnat

    # 放行本机代理进程
    $1 -t nat -A SSTP_OUTPUT \
        -m owner --gid-owner $proxy_procgroup \
        -j RETURN

    # 本机传出流量 => SSTP_RULE
    $1 -t nat -A SSTP_OUTPUT \
        -p tcp \
        -m tcp --syn \
        -m addrtype --src-type LOCAL ! --dst-type LOCAL \
        $(get_dst_port_match) \
        -j SSTP_RULE

    # 内网传出流量 => SSTP_RULE
    # 所有发往LOCAL地址的包都会走这里，注意判定
    is_proxy_other &&
        $1 -t nat -A SSTP_PREROUTING \
            -p tcp \
            -m tcp --syn \
            -m addrtype ! --src-type LOCAL ! --dst-type LOCAL \
            $(get_dst_port_match) \
            -j SSTP_RULE
}

# nat表 OUTPUT/PREROUTING -p udp
# $ipts bypass:0/1
redir_dns_request() {
    local bypass=$2

    # 放行本机代理进程
    ((bypass)) &&
        $1 -t nat -A SSTP_OUTPUT \
            -m owner --gid-owner $proxy_procgroup \
            -j RETURN

    # 本机发出的dns请求
    $1 -t nat -A SSTP_OUTPUT \
        -p udp \
        -m udp --dport 53 \
        -m conntrack --ctstate NEW \
        -m owner ! --gid-owner $dns_procgroup \
        -j REDIRECT --to-ports $dns_mainport

    # dns进程 => dns2tcp
    is_enabled_dns2tcp &&
        $1 -t nat -A SSTP_OUTPUT \
            -d $remote_dns_ip \
            -p udp \
            -m udp --dport $remote_dns_port \
            -m conntrack --ctstate NEW \
            -m owner --gid-owner $dns_procgroup \
            -j REDIRECT --to-ports $dns2tcp_bind_port

    # 其他主机发来的dns请求
    is_proxy_other && ((dns_mainport != 53)) &&
        $1 -t nat -A SSTP_PREROUTING \
            -p udp \
            -m udp --dport 53 \
            -m conntrack --ctstate NEW \
            -m addrtype ! --src-type LOCAL --dst-type LOCAL \
            -j REDIRECT --to-ports $dns_mainport
}

start_iptables_tproxy() {
    # 处理tcp/udp mangle表
    do_proxy_tproxy $1

    # 处理dns(udp) nat表
    local bypass=1
    redir_dns_request $1 $bypass
}

start_iptables_redirect() {
    # 处理tcp nat表
    do_proxy_dnat $1

    # 处理udp mangle表
    if is_enabled_udp; then
        do_proxy_tproxy $1
    fi

    # 处理dns(udp) nat表
    local bypass=0 # do_proxy_dnat里面已经放行了
    redir_dns_request $1 $bypass
}

_start_iptables() {
    start_iptables_pre $1

    local loopback_addr loopback_addrx remote_dns_ip remote_dns_port white_setname black_setname
    init_iptables_param $1

    if is_true "$tproxy"; then
        start_iptables_tproxy $1
    else
        start_iptables_redirect $1
    fi

    if is_proxy_other; then
        add_snat_rule $1
    fi

    start_iptables_post $1
}

start_iptables() {
    is_enabled_ipv4 && _start_iptables "iptables"
    is_enabled_ipv6 && _start_iptables "ip6tables"
}

_delete_unused_chain() {
    local list=(
        mangle PREROUTING
        mangle OUTPUT
        nat PREROUTING
        nat OUTPUT
        nat POSTROUTING
    )
    for ((i = 0; i < ${#list[@]}; i += 2)); do
        local table="${list[i]}" chain="${list[i+1]}"
        if chain_is_empty $1 $table SSTP_$chain; then
            $1 -t $table -D $chain -j SSTP_$chain
            $1 -t $table -X SSTP_$chain
        fi
    done
}

delete_unused_chain() {
    is_enabled_ipv4 && _delete_unused_chain "iptables"
    is_enabled_ipv6 && _delete_unused_chain "ip6tables"
}

_flush_iptables() {
    $1 -t mangle -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    $1 -t mangle -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null
    $1 -t nat    -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null
    $1 -t nat    -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null
    $1 -t nat    -D POSTROUTING -j SSTP_POSTROUTING &>/dev/null

    # todo 改为 grep 匹配 (SSTP_*)，便于维护
    $1 -t mangle -F SSTP_PREROUTING  &>/dev/null
    $1 -t mangle -X SSTP_PREROUTING  &>/dev/null
    $1 -t mangle -F SSTP_OUTPUT      &>/dev/null
    $1 -t mangle -X SSTP_OUTPUT      &>/dev/null
    $1 -t nat    -F SSTP_PREROUTING  &>/dev/null
    $1 -t nat    -X SSTP_PREROUTING  &>/dev/null
    $1 -t nat    -F SSTP_OUTPUT      &>/dev/null
    $1 -t nat    -X SSTP_OUTPUT      &>/dev/null
    $1 -t nat    -F SSTP_POSTROUTING &>/dev/null
    $1 -t nat    -X SSTP_POSTROUTING &>/dev/null

    $1 -t mangle -F SSTP_RULE &>/dev/null
    $1 -t mangle -X SSTP_RULE &>/dev/null
    $1 -t nat    -F SSTP_RULE &>/dev/null
    $1 -t nat    -X SSTP_RULE &>/dev/null
}

flush_iptables() {
    # 不做判断，防止相关配置改动导致残留
    _flush_iptables "iptables"
    _flush_iptables "ip6tables"
}

_show_iptables() {
    echo "$(color_green "==> $1-mangle <==")"
    $1 -t mangle -S
    echo
    echo "$(color_green "==> $1-nat <==")"
    $1 -t nat -S
}

show_iptables() {
    is_enabled_ipv4 && _show_iptables "iptables"
    { is_enabled_ipv4 && is_enabled_ipv6; } && echo
    is_enabled_ipv6 && _show_iptables "ip6tables"
}

start() {
    ss_tproxy_is_started && { stop; status; echo; }

    flush_stoprule

    is_func pre_start && pre_start

    set_kernel_param
    start_proxyproc
    start_ipset
    start_dnsserver
    start_iproute
    start_iptables

    is_func post_start && post_start

    delete_unused_chain
}

stop() {
    is_func pre_stop && pre_stop

    flush_iptables
    flush_iproute
    stop_dnsserver
    flush_ipset
    stop_proxyproc
    add_stoprule

    is_func post_stop && post_stop
}

# name func args...
_status() {
    local name="$1" func="$2"
    shift 2
    if $func "$@"; then
        echo -e "$name:\t$(color_green '[running]')"
    else
        echo -e "$name:\t$(color_red '[stopped]')"
    fi
}

status() {
    echo -e "mode:\t\t$(font_bold $mode)"

    _status "proxy/tcp" tcp_port_is_exists $proxy_tcpport
    is_enabled_udp && _status "proxy/udp" udp_port_is_exists $proxy_udpport

    if is_built_in_dns; then
        _status "dnsmasq" process_is_running $pid_dnsmasq
        is_enabled_chinadns && _status "chinadns" process_is_running $pid_chinadns
    fi

    if is_enabled_dns2tcp; then
        is_enabled_ipv4 && _status "dns2tcp4" process_is_running $pid_dns2tcp4
        is_enabled_ipv6 && _status "dns2tcp6" process_is_running $pid_dns2tcp6
    fi

    is_func extra_status && extra_status
}

version() {
    echo "ss-tproxy v4.7 (2023-04-27)"
}

help() {
    cat <<EOF
Usage: ss-tproxy <COMMAND> ... [-x] [-d basedir] [-c config] [name=value ...]
COMMAND := {
    start               start ss-tproxy
    stop                stop ss-tproxy
    restart             restart ss-tproxy
    status              status of ss-tproxy
    show-iptables       show iptables rules
    flush-stoprule      flush stop iptables rules
    flush-dnscache      flush dns cache
    update-gfwlist      update gfwlist.txt
    update-chnlist      update chnlist.txt
    update-chnroute     update chnroute.txt
    version             show version and exit
    help                show help and exit
}
Specify the -x option to debug script
Specify the -d option to use given base dir
Specify the -c option to use given ss-tproxy.conf
Specify the name=value to override ss-tproxy config
Issues or bug report: https://github.com/zfl9/ss-tproxy
See https://github.com/zfl9/ss-tproxy/wiki for more details
EOF
}

main() {
    local argv=("$@")
    local arg_list=() #所有位置参数 会传给ss-tproxy.conf
    local override_list=() #覆盖ss-tproxy.conf中的同名配置

    for ((i = 0; i < ${#argv[@]}; ++i)); do
        local arg="${argv[i]}"
        if [ "$arg" = '-x' ]; then
            set -x
        elif [ "$arg" = '-d' ]; then
            base_dir="${argv[++i]}"
        elif [ "$arg" = '-c' ]; then
            config_file="${argv[++i]}"
        elif str_find "$arg" '='; then
            override_list+=("$arg")
        else
            arg_list+=("$arg")
        fi
    done

    if [ "${#arg_list[@]}" -eq 0 ]; then
        help
        return 0
    fi

    cd $base_dir

    load_pidfile
    load_config
    check_config

    case "${arg_list[0]}" in
        start)           start; status;;
        stop)            stop; status;;
        r*)              stop; status; echo; start; status;;
        stat*)           status;;
        show*)           show_iptables;;
        flush-stop*)     flush_stoprule;;
        flush-dns*)      flush_dnscache;;
        update-gfwlist)  update_gfwlist;;
        update-chnlist)  update_chnlist;;
        update-chnroute) update_chnroute;;
        v*)              version;;
        h*)              help;;
        *)               echo "$(color_yellow "Unknown command: ${arg_list[0]}")"; help; return 1;;
    esac

    return 0
}

main "$@"
