#!/bin/bash
set -o pipefail

font_bold() {
    printf "\e[1m$*\e[0m"
}

color_red() {
    printf "\e[35m$*\e[0m"
}

color_green() {
    printf "\e[32m$*\e[0m"
}

color_yellow() {
    printf "\e[31m$*\e[0m"
}

log_info() {
    echo "$(font_bold $(color_green '[INFO]')) $*"
}

log_warn() {
    echo "$(font_bold $(color_red '[WARN]')) $*" 1>&2
}

log_error() {
    echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2
    exit 1
}

file_is_exists() {
    [ -f "$1" ]
}

file_is_not_empty() {
    [ -s "$1" ]
}

command_is_exists() {
    command -v "$1" &>/dev/null
}

process_is_running() {
    kill -0 "$1" &>/dev/null
}

sstproxy_is_started() {
    # simple detection (may not be accurate)
    iptables -t mangle -L SSTP_OUT &>/dev/null
}

ss_tproxy_config='/etc/ss-tproxy/ss-tproxy.conf'
PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

# check core file is exists
file_is_exists "$ss_tproxy_config"   || log_error "file not found: $ss_tproxy_config"
source "$ss_tproxy_config" || log_error "failed to load config file, exit-code: $?"
file_is_exists "$file_gfwlist_txt"   || log_error "file not found: $file_gfwlist_txt"
file_is_exists "$file_gfwlist_ext"   || log_error "file not found: $file_gfwlist_ext"
file_is_exists "$file_chnroute_txt"  || log_error "file not found: $file_chnroute_txt"
file_is_exists "$file_chnroute_set"  || log_error "file not found: $file_chnroute_set"
file_is_exists "$file_chnroute6_set" || log_error "file not found: $file_chnroute6_set"

# check `opts_ss_netstat` option
case "$opts_ss_netstat" in
    auto)
        if command_is_exists 'ss'; then
            netstat='ss'
        elif command_is_exists 'netstat'; then
            netstat='netstat'
        else
            log_error "command not found: ss/netstat"
        fi
        ;;
    ss)
        command_is_exists 'ss' && netstat='ss' || log_error "command not found: ss"
        ;;
    netstat)
        command_is_exists 'netstat' && netstat='netstat' || log_error "command not found: netstat"
        ;;
    *)
        log_error "opts_ss_netstat option value is invalid: $opts_ss_netstat"
        ;;
esac

# load `ss-tproxy.status` file
if sstproxy_is_started; then
    source "$file_sstproxy_status" || log_error "failed to load status file, exit-code: $?"
else
    rm -fr "$file_sstproxy_status" &>/dev/null
fi

# ipv4 reserved ipaddrs
ipv4_reserved_ipaddrs=(
    0.0.0.0/8
    10.0.0.0/8
    100.64.0.0/10
    127.0.0.0/8
    169.254.0.0/16
    172.16.0.0/12
    192.0.0.0/24
    192.0.2.0/24
    192.88.99.0/24
    192.168.0.0/16
    198.18.0.0/15
    198.51.100.0/24
    203.0.113.0/24
    224.0.0.0/4
    240.0.0.0/4
    255.255.255.255/32
)

# ipv6 reserved ipaddrs
ipv6_reserved_ipaddrs=(
    ::/128
    ::1/128
    ::ffff:0:0/96
    ::ffff:0:0:0/96
    64:ff9b::/96
    100::/64
    2001::/32
    2001:20::/28
    2001:db8::/32
    2002::/16
    fc00::/7
    fe80::/10
    ff00::/8
)

check_command() {
    command_is_exists 'ip' || log_error "command not found: ip"
    command_is_exists 'dnsmasq' || log_error "command not found: dnsmasq"
    command_is_exists 'iptables' || log_error "command not found: iptables"
    [ "$ipv6" != 'default' ] && { command_is_exists 'ip6tables' || log_error "command not found: ip6tables"; }

    case "$mode" in
        gfwlist)
            command_is_exists 'curl'   || log_warn  "command not found: curl"
            command_is_exists 'base64' || log_warn  "command not found: base64"
            command_is_exists 'perl'   || log_warn  "command not found: perl"
            command_is_exists 'ipset'  || log_error "command not found: ipset"
            ;;
        chnroute)
            command_is_exists 'curl'  || log_warn  "command not found: curl"
            command_is_exists 'ipset' || log_error "command not found: ipset"
            if [ "$chinadnsng_enable" = 'false' ]; then
                command_is_exists 'chinadns' || log_error "command not found: chinadns"
            else
                command_is_exists "chinadns-ng" || log_error "command not found: chinadns-ng"
            fi
            ;;
    esac
}
check_command

update_chnonly() {
    local url='https://raw.github.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"
    echo "$data" | gawk -F/ '{print $2}' >$file_gfwlist_txt
}

update_gfwlist() {
    local url='https://raw.github.com/gfwlist/gfwlist/master/gfwlist.txt'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"
    local base64_decode='' # store `base64 -d/--decode` command
    base64 -d       </dev/null &>/dev/null && base64_decode='base64 -d'
    base64 --decode </dev/null &>/dev/null && base64_decode='base64 --decode'
    [ "$base64_decode" ] || log_error "command args is not support: base64 -d/--decode"
    echo "$data" | $base64_decode | { perl -pe '
    if (/URL Keywords/i) { $null = <> until $null =~ /^!/ }
    s#^\s*+$|^!.*+$|^@@.*+$|^\[AutoProxy.*+$|^/.*/$##i;
    s@^\|\|?|\|$@@;
    s@^https?:/?/?@@i;
    s@(?:/|%).*+$@@;
    s@\*[^.*]++$@\n@;
    s@^.*?\*[^.]*+(?=[^*]+$)@@;
    s@^\*?\.|^.*\.\*?$@@;
    s@(?=[^0-9a-zA-Z.-]).*+$@@;
    s@^\d+\.\d+\.\d+\.\d+(?::\d+)?$@@;
    s@^\s*+$@@'
    printf 'twimg.edgesuite.net\n'
    printf 'blogspot.ae\nblogspot.al\nblogspot.am\nblogspot.ba\nblogspot.be\nblogspot.bg\nblogspot.bj\nblogspot.ca\nblogspot.cat\nblogspot.cf\nblogspot.ch\nblogspot.cl\nblogspot.co.at\nblogspot.co.id\nblogspot.co.il\nblogspot.co.ke\nblogspot.com\nblogspot.com.ar\nblogspot.com.au\nblogspot.com.br\nblogspot.com.by\nblogspot.com.co\nblogspot.com.cy\nblogspot.com.ee\nblogspot.com.eg\nblogspot.com.es\nblogspot.com.mt\nblogspot.com.ng\nblogspot.com.tr\nblogspot.com.uy\nblogspot.co.nz\nblogspot.co.uk\nblogspot.co.za\nblogspot.cv\nblogspot.cz\nblogspot.de\nblogspot.dk\nblogspot.fi\nblogspot.fr\nblogspot.gr\nblogspot.hk\nblogspot.hr\nblogspot.hu\nblogspot.ie\nblogspot.in\nblogspot.is\nblogspot.it\nblogspot.jp\nblogspot.kr\nblogspot.li\nblogspot.lt\nblogspot.lu\nblogspot.md\nblogspot.mk\nblogspot.mr\nblogspot.mx\nblogspot.my\nblogspot.nl\nblogspot.no\nblogspot.pe\nblogspot.pt\nblogspot.qa\nblogspot.re\nblogspot.ro\nblogspot.rs\nblogspot.ru\nblogspot.se\nblogspot.sg\nblogspot.si\nblogspot.sk\nblogspot.sn\nblogspot.td\nblogspot.tw\nblogspot.ug\nblogspot.vn\n'
    printf 'google.ac\ngoogle.ad\ngoogle.ae\ngoogle.al\ngoogle.am\ngoogle.as\ngoogle.at\ngoogle.az\ngoogle.ba\ngoogle.be\ngoogle.bf\ngoogle.bg\ngoogle.bi\ngoogle.bj\ngoogle.bs\ngoogle.bt\ngoogle.by\ngoogle.ca\ngoogle.cat\ngoogle.cc\ngoogle.cd\ngoogle.cf\ngoogle.cg\ngoogle.ch\ngoogle.ci\ngoogle.cl\ngoogle.cm\ngoogle.cn\ngoogle.co.ao\ngoogle.co.bw\ngoogle.co.ck\ngoogle.co.cr\ngoogle.co.id\ngoogle.co.il\ngoogle.co.in\ngoogle.co.jp\ngoogle.co.ke\ngoogle.co.kr\ngoogle.co.ls\ngoogle.com\ngoogle.co.ma\ngoogle.com.af\ngoogle.com.ag\ngoogle.com.ai\ngoogle.com.ar\ngoogle.com.au\ngoogle.com.bd\ngoogle.com.bh\ngoogle.com.bn\ngoogle.com.bo\ngoogle.com.br\ngoogle.com.bz\ngoogle.com.co\ngoogle.com.cu\ngoogle.com.cy\ngoogle.com.do\ngoogle.com.ec\ngoogle.com.eg\ngoogle.com.et\ngoogle.com.fj\ngoogle.com.gh\ngoogle.com.gi\ngoogle.com.gt\ngoogle.com.hk\ngoogle.com.jm\ngoogle.com.kh\ngoogle.com.kw\ngoogle.com.lb\ngoogle.com.lc\ngoogle.com.ly\ngoogle.com.mm\ngoogle.com.mt\ngoogle.com.mx\ngoogle.com.my\ngoogle.com.na\ngoogle.com.nf\ngoogle.com.ng\ngoogle.com.ni\ngoogle.com.np\ngoogle.com.om\ngoogle.com.pa\ngoogle.com.pe\ngoogle.com.pg\ngoogle.com.ph\ngoogle.com.pk\ngoogle.com.pr\ngoogle.com.py\ngoogle.com.qa\ngoogle.com.sa\ngoogle.com.sb\ngoogle.com.sg\ngoogle.com.sl\ngoogle.com.sv\ngoogle.com.tj\ngoogle.com.tr\ngoogle.com.tw\ngoogle.com.ua\ngoogle.com.uy\ngoogle.com.vc\ngoogle.com.vn\ngoogle.co.mz\ngoogle.co.nz\ngoogle.co.th\ngoogle.co.tz\ngoogle.co.ug\ngoogle.co.uk\ngoogle.co.uz\ngoogle.co.ve\ngoogle.co.vi\ngoogle.co.za\ngoogle.co.zm\ngoogle.co.zw\ngoogle.cv\ngoogle.cz\ngoogle.de\ngoogle.dj\ngoogle.dk\ngoogle.dm\ngoogle.dz\ngoogle.ee\ngoogle.es\ngoogle.fi\ngoogle.fm\ngoogle.fr\ngoogle.ga\ngoogle.ge\ngoogle.gf\ngoogle.gg\ngoogle.gl\ngoogle.gm\ngoogle.gp\ngoogle.gr\ngoogle.gy\ngoogle.hn\ngoogle.hr\ngoogle.ht\ngoogle.hu\ngoogle.ie\ngoogle.im\ngoogle.io\ngoogle.iq\ngoogle.is\ngoogle.it\ngoogle.je\ngoogle.jo\ngoogle.kg\ngoogle.ki\ngoogle.kz\ngoogle.la\ngoogle.li\ngoogle.lk\ngoogle.lt\ngoogle.lu\ngoogle.lv\ngoogle.md\ngoogle.me\ngoogle.mg\ngoogle.mk\ngoogle.ml\ngoogle.mn\ngoogle.ms\ngoogle.mu\ngoogle.mv\ngoogle.mw\ngoogle.ne\ngoogle.net\ngoogle.nl\ngoogle.no\ngoogle.nr\ngoogle.nu\ngoogle.org\ngoogle.pl\ngoogle.pn\ngoogle.ps\ngoogle.pt\ngoogle.ro\ngoogle.rs\ngoogle.ru\ngoogle.rw\ngoogle.sc\ngoogle.se\ngoogle.sh\ngoogle.si\ngoogle.sk\ngoogle.sm\ngoogle.sn\ngoogle.so\ngoogle.sr\ngoogle.st\ngoogle.td\ngoogle.tg\ngoogle.tk\ngoogle.tl\ngoogle.tm\ngoogle.tn\ngoogle.to\ngoogle.tt\ngoogle.vg\ngoogle.vu\ngoogle.ws\n'
    } | sort | uniq >$file_gfwlist_txt
}

update_chnroute() {
    # download delegated apnic file
    local url='http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"

    # update chnroute (chinadns only support ipv4)
    for reserved_addr in "${ipv4_reserved_ipaddrs[@]}"; do echo "$reserved_addr"; done >$file_chnroute_txt
    echo "$data" | grep CN | grep ipv4 | gawk -F'|' '{printf("%s/%d\n", $4, 32-log($5)/log(2))}' >>$file_chnroute_txt
    echo 'create chnroute hash:net family inet' >$file_chnroute_set; sed -r 's/^.+$/add chnroute &/' $file_chnroute_txt >>$file_chnroute_set

    # update chnroute6 (chinadns-ng support ipv4/ipv6)
    echo 'create chnroute6 hash:net family inet6' >$file_chnroute6_set
    for reserved_addr in "${ipv6_reserved_ipaddrs[@]}"; do echo "add chnroute6 $reserved_addr"; done >>$file_chnroute6_set
    echo "$data" | grep CN | grep ipv6 | gawk -F'|' '{printf("add chnroute6 %s/%d\n", $4, $5)}' >>$file_chnroute6_set
}

flush_dnscache() {
    kill -HUP "$status_dnsmasq_pid" &>/dev/null
}

start_proxy() {
    eval "$proxy_runcmd" || log_error "failed to exec proxy_runcmd: $proxy_runcmd"
}

start_resolver_global() {
    status_dnsmasq_pid=$(dnsmasq --no-daemon --conf-file <(cat <<EOF
$([ "$dnsmasq_log_enable" = 'true' ] && echo 'log-queries')
log-facility = $dnsmasq_log_file
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$([ $(dnsmasq --help | grep -c min-cache-ttl) -ne 0 ] && echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = 60053
server = $(tr ':' '#' <<<"$dns_remote")
$(for server_addr in "${server_addrs[@]}"; do echo "address = $server_addr"; done)
EOF
) </dev/null &>>$dnsmasq_log_file & echo $!)
}

start_resolver_gfwlist() {
    status_dnsmasq_pid=$(dnsmasq --no-daemon --conf-file <(cat <<EOF
$([ "$dnsmasq_log_enable" = 'true' ] && echo 'log-queries')
log-facility = $dnsmasq_log_file
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$([ $(dnsmasq --help | grep -c min-cache-ttl) -ne 0 ] && echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = 60053
server = $dns_direct
$(for server_addr in "${server_addrs[@]}"; do echo "address = $server_addr"; done)
$(perl -pe "s@^.*+\$@server=/$&/$(tr ':' '#' <<<"$dns_remote")\nipset=/$&/gfwlist@" $file_gfwlist_txt <(
perl -ne 'print unless m@^\s|\s\n$|^#|^\d++\.\d++\.\d++\.\d++(?:/\d++)?$@' $file_gfwlist_ext
))
EOF
) </dev/null &>>$dnsmasq_log_file & echo $!)
}

start_resolver_chnroute() {
    local temp_chnroute_txt=$(mktemp)
    cat $file_chnroute_txt >$temp_chnroute_txt
    echo "$dns_direct/32" >>$temp_chnroute_txt
    for intranet in "${ipts_intranet[@]}"; do echo "$intranet" >>$temp_chnroute_txt; done

    local chinadns_params="-b 127.0.0.1 -p 65353 -s $dns_direct,$dns_remote -c $temp_chnroute_txt -y 0"
    [ "$chinadns_mutation" = 'true' ] && chinadns_params+=' -m'
    [ "$chinadns_verbose"  = 'true' ] && chinadns_params+=' -v'

    status_chinadns_pid=$(chinadns $chinadns_params </dev/null &>>$chinadns_logfile & echo $!)

    status_dnsmasq_pid=$(dnsmasq --no-daemon --conf-file <(cat <<EOF
$([ "$dnsmasq_log_enable" = 'true' ] && echo 'log-queries')
log-facility = $dnsmasq_log_file
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$([ $(dnsmasq --help | grep -c min-cache-ttl) -ne 0 ] && echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = 60053
server = 127.0.0.1#65353
$(for server_addr in "${server_addrs[@]}"; do echo "address = $server_addr"; done)
EOF
) </dev/null &>>$dnsmasq_log_file & echo $!)
}

start_resolver() {
    # resolve hostname
    local server_addrs=()
    for server in "${proxy_server[@]}"; do
        if [ $(grep -Ec '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' <<<"$server") -eq 0 ]; then
            server_addrs+=("/$server/$(ping -nq -c1 -t1 -W1 $server | head -n1 | gawk -F'[()]' '{print $2}')") || true
        fi
    done
    case "$mode" in
        global)
            start_resolver_global
            ;;
        gfwlist)
            start_resolver_gfwlist
            ;;
        chnroute)
            start_resolver_chnroute
            ;;
    esac
}

start_iptables() {
    sysctl -w net.ipv4.ip_forward=1 &>/dev/null
    for dir in $(ls /proc/sys/net/ipv4/conf); do
        sysctl -w net.ipv4.conf.$dir.send_redirects=0 &>/dev/null
    done

    check_snat_rule() {
        if [ "$ipts_non_snat" != 'true' ]; then
            if ! iptables -t nat -C POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE &>/dev/null; then
                iptables -t nat -A POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE
            fi
        fi
    }

    dec2bin() {
        for ((n = $1; n > 0; n >>= 1)); do bit="$((n & 1))$bit"; done
        printf "%08d\n" "$bit"
    }

    net2bin() {
        net=$(gawk -F/ '{print $1}' <<<$1)
        len=$(gawk -F/ '{print $2}' <<<$1)
        IFS='.' read -ra bytes <<<"$net"
        for byte in "${bytes[@]}"; do result+="$(dec2bin $byte)"; done
        echo "${result:0:len}"
    }

    for cidr in "${ipts_intranet[@]}"; do
        curnet=$(net2bin $cidr)
        for stdnet in 00001010 101011000001 1010100111111110 1100000010101000; do
            [[ "$curnet" == "$stdnet"* ]] && continue 2
        done
        ipts_intranet_nonstd+=($cidr)
    done

    iptables -t mangle -N SSTP_OUT
    iptables -t mangle -N SSTP_PRE
    iptables -t nat    -N SSTP_OUT
    iptables -t nat    -N SSTP_PRE

    iptables -t mangle -A OUTPUT     -j SSTP_OUT
    iptables -t mangle -A PREROUTING -j SSTP_PRE
    iptables -t nat    -A OUTPUT     -j SSTP_OUT
    iptables -t nat    -A PREROUTING -j SSTP_PRE

    ip route add local 0/0 dev lo     table $ipts_rt_tab
    ip rule  add fwmark $ipts_rt_mark table $ipts_rt_tab

if [ "$proxy_tproxy" = 'true' ]; then
case "$mode" in
gfwlist)
    ipset -N gfwlist hash:net &>/dev/null
    perl -ne 'print if m@^\d++\.\d++\.\d++\.\d++(?:/\d++)?$@' $file_gfwlist_ext | xargs -n1 ipset -A gfwlist &>/dev/null

    iptables -t mangle -N SETMARK
    if ! [ "$proxy_dports" ]; then
        for server in "${proxy_server[@]}"; do
            iptables -t mangle -A SETMARK -d $server -j RETURN
        done
    else
        for server in "${proxy_server[@]}"; do
            iptables -t mangle -A SETMARK -d $server -p tcp -m multiport --dports $proxy_dports -j RETURN
            iptables -t mangle -A SETMARK -d $server -p udp -m multiport --dports $proxy_dports -j RETURN
        done
    fi
    iptables -t mangle -A SETMARK -p udp -d ${dns_remote%:*}     -j MARK --set-mark $ipts_rt_mark
    iptables -t mangle -A SETMARK -m set --match-set gfwlist dst -j MARK --set-mark $ipts_rt_mark

    iptables -t mangle -A SSTP_OUT -p tcp -j SETMARK
    iptables -t mangle -A SSTP_OUT -p udp -j SETMARK
    iptables -t nat    -A SSTP_OUT -p udp -d 127.0.0.1 --dport 53 -j REDIRECT --to-ports 60053

    for intranet in "${ipts_intranet[@]}"; do
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j ACCEPT
        iptables -t nat    -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j REDIRECT --to-ports 60053

        iptables -t mangle -A SSTP_PRE -p tcp -s $intranet            -m mark ! --mark $ipts_rt_mark -j SETMARK
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet            -m mark ! --mark $ipts_rt_mark -j SETMARK

        check_snat_rule
    done

    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_tcport
    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p udp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_udport
    ;;
global|chnroute)
    iptables -t mangle -N SETMARK
    iptables -t mangle -A SETMARK -d 0/8        -j RETURN
    iptables -t mangle -A SETMARK -d 10/8       -j RETURN
    iptables -t mangle -A SETMARK -d 127/8      -j RETURN
    iptables -t mangle -A SETMARK -d 169.254/16 -j RETURN
    iptables -t mangle -A SETMARK -d 172.16/12  -j RETURN
    iptables -t mangle -A SETMARK -d 192.168/16 -j RETURN
    for cidr in "${ipts_intranet_nonstd[@]}"; do
        iptables -t mangle -A SETMARK -d $cidr -j RETURN
    done
    iptables -t mangle -A SETMARK -d 224/4 -j RETURN
    iptables -t mangle -A SETMARK -d 240/4 -j RETURN
    if ! [ "$proxy_dports" ]; then
        for server in "${proxy_server[@]}"; do
            iptables -t mangle -A SETMARK -d $server -j RETURN
        done
    else
        for server in "${proxy_server[@]}"; do
            iptables -t mangle -A SETMARK -d $server -p tcp -m multiport --dports $proxy_dports -j RETURN
            iptables -t mangle -A SETMARK -d $server -p udp -m multiport --dports $proxy_dports -j RETURN
        done
    fi
    if [ "$mode" = chnroute ]; then
        ipset -X chnroute &>/dev/null
        ipset -R <$file_chnroute_set
        iptables -t mangle -A SETMARK -m set --match-set chnroute dst -j RETURN
    fi
    iptables -t mangle -A SETMARK -j MARK --set-mark $ipts_rt_mark

    iptables -t mangle -A SSTP_OUT -p tcp -j SETMARK
    iptables -t mangle -A SSTP_OUT -p udp -j SETMARK
    iptables -t nat    -A SSTP_OUT -p udp -d 127.0.0.1 --dport 53 -j REDIRECT --to-ports 60053

    for intranet in "${ipts_intranet[@]}"; do
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j ACCEPT
        iptables -t nat    -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j REDIRECT --to-ports 60053

        iptables -t mangle -A SSTP_PRE -p tcp -s $intranet            -m mark ! --mark $ipts_rt_mark -j SETMARK
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet            -m mark ! --mark $ipts_rt_mark -j SETMARK

        check_snat_rule
    done

    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p tcp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_tcport
    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p udp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_udport
    ;;
esac
else
case "$mode" in
gfwlist)
    ipset -N gfwlist hash:net &>/dev/null
    perl -ne 'print if m@^\d++\.\d++\.\d++\.\d++(?:/\d++)?$@' $file_gfwlist_ext | xargs -n1 ipset -A gfwlist &>/dev/null

    iptables -t nat -N TCPCHAIN
    for server in "${proxy_server[@]}"; do
        iptables -t nat -A TCPCHAIN -d $server $([ "$proxy_dports" ] && echo "-p tcp -m multiport --dports $proxy_dports") -j RETURN
    done
    iptables -t nat -A TCPCHAIN -p tcp -m set --match-set gfwlist dst -j REDIRECT --to-ports $proxy_tcport

    iptables -t mangle -N UDPCHAIN
    for server in "${proxy_server[@]}"; do
        iptables -t mangle -A UDPCHAIN -d $server $([ "$proxy_dports" ] && echo "-p udp -m multiport --dports $proxy_dports") -j RETURN
    done
    iptables -t mangle -A UDPCHAIN -d ${dns_remote%:*}            -j MARK --set-mark $ipts_rt_mark
    iptables -t mangle -A UDPCHAIN -m set --match-set gfwlist dst -j MARK --set-mark $ipts_rt_mark

    iptables -t nat    -A SSTP_OUT -p tcp -j TCPCHAIN
    iptables -t mangle -A SSTP_OUT -p udp -j UDPCHAIN
    iptables -t nat    -A SSTP_OUT -p udp -d 127.0.0.1 --dport 53 -j REDIRECT --to-ports 60053

    for intranet in "${ipts_intranet[@]}"; do
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j ACCEPT
        iptables -t nat    -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j REDIRECT --to-ports 60053

        iptables -t nat    -A SSTP_PRE -p tcp -s $intranet                                -j TCPCHAIN
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet -m mark ! --mark $ipts_rt_mark -j UDPCHAIN

        check_snat_rule
    done

    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p udp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_udport
    ;;
global|chnroute)
    iptables -t nat -N TCPCHAIN
    iptables -t nat -A TCPCHAIN -d 0/8        -j RETURN
    iptables -t nat -A TCPCHAIN -d 10/8       -j RETURN
    iptables -t nat -A TCPCHAIN -d 127/8      -j RETURN
    iptables -t nat -A TCPCHAIN -d 169.254/16 -j RETURN
    iptables -t nat -A TCPCHAIN -d 172.16/12  -j RETURN
    iptables -t nat -A TCPCHAIN -d 192.168/16 -j RETURN
    for cidr in "${ipts_intranet_nonstd[@]}"; do
        iptables -t nat -A TCPCHAIN -d $cidr -j RETURN
    done
    iptables -t nat -A TCPCHAIN -d 224/4 -j RETURN
    iptables -t nat -A TCPCHAIN -d 240/4 -j RETURN
    for server in "${proxy_server[@]}"; do
        iptables -t nat -A TCPCHAIN -d $server $([ "$proxy_dports" ] && echo "-p tcp -m multiport --dports $proxy_dports") -j RETURN
    done
    if [ "$mode" = chnroute ]; then
        ipset -X chnroute &>/dev/null
        ipset -R <$file_chnroute_set
        iptables -t nat -A TCPCHAIN -m set --match-set chnroute dst -j RETURN
    fi
    iptables -t nat -A TCPCHAIN -p tcp -j REDIRECT --to-ports $proxy_tcport

    iptables -t mangle -N UDPCHAIN
    iptables -t mangle -A UDPCHAIN -d 0/8        -j RETURN
    iptables -t mangle -A UDPCHAIN -d 10/8       -j RETURN
    iptables -t mangle -A UDPCHAIN -d 127/8      -j RETURN
    iptables -t mangle -A UDPCHAIN -d 169.254/16 -j RETURN
    iptables -t mangle -A UDPCHAIN -d 172.16/12  -j RETURN
    iptables -t mangle -A UDPCHAIN -d 192.168/16 -j RETURN
    for cidr in "${ipts_intranet_nonstd[@]}"; do
        iptables -t mangle -A UDPCHAIN -d $cidr -j RETURN
    done
    iptables -t mangle -A UDPCHAIN -d 224/4 -j RETURN
    iptables -t mangle -A UDPCHAIN -d 240/4 -j RETURN
    for server in "${proxy_server[@]}"; do
        iptables -t mangle -A UDPCHAIN -d $server $([ "$proxy_dports" ] && echo "-p udp -m multiport --dports $proxy_dports") -j RETURN
    done
    if [ "$mode" = chnroute ]; then
        iptables -t mangle -A UDPCHAIN -m set --match-set chnroute dst -j RETURN
    fi
    iptables -t mangle -A UDPCHAIN -j MARK --set-mark $ipts_rt_mark

    iptables -t nat    -A SSTP_OUT -p tcp -j TCPCHAIN
    iptables -t mangle -A SSTP_OUT -p udp -j UDPCHAIN
    iptables -t nat    -A SSTP_OUT -p udp -d 127.0.0.1 --dport 53 -j REDIRECT --to-ports 60053

    for intranet in "${ipts_intranet[@]}"; do
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j ACCEPT
        iptables -t nat    -A SSTP_PRE -p udp -s $intranet --dport 53 -m mark ! --mark $ipts_rt_mark -j REDIRECT --to-ports 60053

        iptables -t nat    -A SSTP_PRE -p tcp -s $intranet                                -j TCPCHAIN
        iptables -t mangle -A SSTP_PRE -p udp -s $intranet -m mark ! --mark $ipts_rt_mark -j UDPCHAIN

        check_snat_rule
    done

    iptables -t mangle -A SSTP_PRE -m mark --mark $ipts_rt_mark -p udp -j TPROXY --on-ip 127.0.0.1 --on-port $proxy_udport
    ;;
esac
fi
}

start_dnsproxy() {
    if [ "$dns_modify" = 'false' ]; then
        while umount /etc/resolv.conf; do :; done &>/dev/null
        resolv=$(mktemp)
        chmod 0644 $resolv
        cat <<EOF >$resolv
# Generated by ss-tproxy at $(date '+%F %T')
nameserver 127.0.0.1
EOF
        mount -o bind $resolv /etc/resolv.conf
        rm -f $resolv &>/dev/null
    else
        echo "# Generated by ss-tproxy at $(date '+%F %T')" >/etc/resolv.conf
        echo "nameserver 127.0.0.1" >>/etc/resolv.conf
    fi
}

start() {
    [ "$(type -t pre_start)" = 'function' ] && pre_start

    if [ "$dns_modify" = 'false' ]; then
        while umount /etc/resolv.conf; do :; done &>/dev/null
    else
        echo "# Generated by ss-tproxy at $(date '+%F %T')" >/etc/resolv.conf
        echo "nameserver $dns_direct" >>/etc/resolv.conf
    fi

    start_proxy
    start_resolver
    start_iptables
    start_dnsproxy

    rm -f $temp_chnroute_txt &>/dev/null

    [ "$(type -t post_start)" = 'function' ] && post_start
}

stop() {
    [ "$(type -t pre_stop)" = 'function' ] && pre_stop

    if [ "$dns_modify" = 'false' ]; then
        while umount /etc/resolv.conf; do :; done &>/dev/null
    else
        echo "# Generated by ss-tproxy at $(date '+%F %T')" >/etc/resolv.conf
        echo "nameserver $dns_direct" >>/etc/resolv.conf
    fi

    iptables -t mangle -D OUTPUT     -j SSTP_OUT &>/dev/null
    iptables -t mangle -D PREROUTING -j SSTP_PRE &>/dev/null
    iptables -t nat    -D OUTPUT     -j SSTP_OUT &>/dev/null
    iptables -t nat    -D PREROUTING -j SSTP_PRE &>/dev/null

    iptables -t mangle -F SSTP_OUT &>/dev/null
    iptables -t mangle -X SSTP_OUT &>/dev/null
    iptables -t mangle -F SSTP_PRE &>/dev/null
    iptables -t mangle -X SSTP_PRE &>/dev/null
    iptables -t nat    -F SSTP_OUT &>/dev/null
    iptables -t nat    -X SSTP_OUT &>/dev/null
    iptables -t nat    -F SSTP_PRE &>/dev/null
    iptables -t nat    -X SSTP_PRE &>/dev/null

    iptables -t mangle -F SETMARK  &>/dev/null
    iptables -t mangle -X SETMARK  &>/dev/null
    iptables -t nat    -F TCPCHAIN &>/dev/null
    iptables -t nat    -X TCPCHAIN &>/dev/null
    iptables -t mangle -F UDPCHAIN &>/dev/null
    iptables -t mangle -X UDPCHAIN &>/dev/null

    if [ "$ipts_non_snat" != 'true' ]; then
        for intranet in "${ipts_intranet[@]}"; do
            if ! iptables -t nat -C POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE &>/dev/null; then
                iptables -t nat -A POSTROUTING -s $intranet ! -d $intranet -j MASQUERADE
            fi
        done
    fi

    ipset -X chnroute &>/dev/null

    ip rule show | grep "fwmark $ipts_rt_mark" | gawk -F: '{print $1}' | xargs -n1 ip rule del pref &>/dev/null
    ip route flush table $ipts_rt_tab &>/dev/null

    eval "$proxy_kilcmd" &>/dev/null
    kill -9 $(pidof 'chinadns') &>/dev/null

    if [ "$opts_ss_netstat" != "netstat" -a "$(command -v ss &>/dev/null && echo 'true')" ]; then
        ss -lnpu | gawk -F, '/:60053[ \t].+"dnsmasq"/ {print $(NF-1)}' | gawk -F= '{print $2}' | sort | uniq | xargs kill -9 &>/dev/null
    else
        netstat -lnpu | gawk -F/ '/:60053[ \t].+dnsmasq/ {print $(NF-1)}' | gawk '{print $NF}' | sort | uniq | xargs kill -9 &>/dev/null
    fi

    [ "$(type -t post_stop)" = 'function' ] && post_stop
}

status() {
case "$mode" in
    global)
        echo "mode:     global"
        [ $($netstat -lnpt | grep -E ":$proxy_tcport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/tcp:  \e[32m[running]\e[0m" || echo -e "pxy/tcp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":$proxy_udport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/udp:  \e[32m[running]\e[0m" || echo -e "pxy/udp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":60053[ \t].+dnsmasq"  | wc -l) -ne 0 ] && echo -e "dnsmasq:  \e[32m[running]\e[0m" || echo -e "dnsmasq:  \e[35m[stopped]\e[0m"
        ;;
    gfwlist)
        echo "mode:     gfwlist"
        [ $($netstat -lnpt | grep -E ":$proxy_tcport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/tcp:  \e[32m[running]\e[0m" || echo -e "pxy/tcp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":$proxy_udport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/udp:  \e[32m[running]\e[0m" || echo -e "pxy/udp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":60053[ \t].+dnsmasq"  | wc -l) -ne 0 ] && echo -e "dnsmasq:  \e[32m[running]\e[0m" || echo -e "dnsmasq:  \e[35m[stopped]\e[0m"
        ;;
    chnroute)
        echo "mode:     chnroute"
        [ $($netstat -lnpt | grep -E ":$proxy_tcport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/tcp:  \e[32m[running]\e[0m" || echo -e "pxy/tcp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":$proxy_udport[ \t]"   | wc -l) -ne 0 ] && echo -e "pxy/udp:  \e[32m[running]\e[0m" || echo -e "pxy/udp:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":60053[ \t].+dnsmasq"  | wc -l) -ne 0 ] && echo -e "dnsmasq:  \e[32m[running]\e[0m" || echo -e "dnsmasq:  \e[35m[stopped]\e[0m"
        [ $($netstat -lnpu | grep -E ":65353[ \t].+chinadns" | wc -l) -ne 0 ] && echo -e "chinadns: \e[32m[running]\e[0m" || echo -e "chinadns: \e[35m[stopped]\e[0m"
        ;;
esac
}

show_iptables() {
    echo -e "\e[36;1m==> mangle <==\e[0m"
    iptables -t mangle -nvL --line-numbers
    echo
    echo -e "\e[36;1m==> nat <==\e[0m"
    iptables -t nat -nvL --line-numbers
}

flush_iptables() {
    iptables -t raw -F
    iptables -t raw -X
    iptables -t mangle -F
    iptables -t mangle -X
    iptables -t nat -F
    iptables -t nat -X
    iptables -t filter -F
    iptables -t filter -X
}

help() {
cat <<EOF
Usage: ss-tproxy <COMMAND>
COMMAND := {
    start               start ss-tproxy
    stop                stop ss-tproxy
    restart             restart ss-tproxy
    status              status of ss-tproxy
    show-iptables       show iptables rules
    flush-iptables      flush iptables rules
    flush-dnscache      flush dns cache
    flush-gfwlist       flush ipset-gfwlist
    update-chnonly      update chnonly
    update-gfwlist      update gfwlist
    update-chnroute     update chnroute
    check-command       check commands
    version             show version and exit
    help                show help and exit
}
Issues or Bug report: zfl9.com@gmail.com (Otokaze)
See https://www.zfl9.com/ss-redir.html for more details
EOF
}

case $1 in
    start)              check_command; start; status;;
    stop)               check_command; stop; status;;
    status)             check_command; status;;
    r*)                 check_command; stop; status; echo; start; status;;
    show-iptables)      show_iptables;;
    flush-iptables)     flush_iptables;;
    flush-gfwlist)      ipset -F gfwlist &>/dev/null;;
    flush-dnscache)     check_command; flush_dnscache;;
    update-chnonly)     check_command; update_chnonly;;
    update-gfwlist)     check_command; update_gfwlist;;
    update-chnroute)    check_command; update_chnroute;;
    c*)                 check_command;;
    v*)                 echo "ss-tproxy v3.0.0";;
    h*)                 help;;
    *)                  help; exit 1;;
esac
