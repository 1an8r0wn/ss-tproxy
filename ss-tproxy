#!/bin/bash
set -o nounset
set -o errexit
set -o pipefail

PATH=$PATH:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin

ss_tproxy_config='/etc/ss-tproxy/ss-tproxy.conf'

ipv4_reserved_ipaddrs=(
    0.0.0.0/8
    10.0.0.0/8
    100.64.0.0/10
    127.0.0.0/8
    169.254.0.0/16
    172.16.0.0/12
    192.0.0.0/24
    192.0.2.0/24
    192.88.99.0/24
    192.168.0.0/16
    198.18.0.0/15
    198.51.100.0/24
    203.0.113.0/24
    224.0.0.0/4
    240.0.0.0/4
    255.255.255.255/32
)

ipv6_reserved_ipaddrs=(
    ::/128
    ::1/128
    ::ffff:0:0/96
    ::ffff:0:0:0/96
    64:ff9b::/96
    100::/64
    2001::/32
    2001:20::/28
    2001:db8::/32
    2002::/16
    fc00::/7
    fe80::/10
    ff00::/8
)

gfwlist_txt_perl_script_string='
if (/URL Keywords/i) { $null = <> until $null =~ /^!/ }
s#^\s*+$|^!.*+$|^@@.*+$|^\[AutoProxy.*+$|^/.*/$##i;
s@^\|\|?|\|$@@;
s@^https?:/?/?@@i;
s@(?:/|%).*+$@@;
s@\*[^.*]++$@\n@;
s@^.*?\*[^.]*+(?=[^*]+$)@@;
s@^\*?\.|^.*\.\*?$@@;
s@(?=[^0-9a-zA-Z.-]).*+$@@;
s@^\d+\.\d+\.\d+\.\d+(?::\d+)?$@@;
s@^\s*+$@@
'

gfwlist_txt_append_domain_names() {
    printf "twimg.edgesuite.net\n"
    printf "blogspot.ae\nblogspot.al\nblogspot.am\nblogspot.ba\nblogspot.be\nblogspot.bg\nblogspot.bj\nblogspot.ca\nblogspot.cat\nblogspot.cf\nblogspot.ch\nblogspot.cl\nblogspot.co.at\nblogspot.co.id\nblogspot.co.il\nblogspot.co.ke\nblogspot.com\nblogspot.com.ar\nblogspot.com.au\nblogspot.com.br\nblogspot.com.by\nblogspot.com.co\nblogspot.com.cy\nblogspot.com.ee\nblogspot.com.eg\nblogspot.com.es\nblogspot.com.mt\nblogspot.com.ng\nblogspot.com.tr\nblogspot.com.uy\nblogspot.co.nz\nblogspot.co.uk\nblogspot.co.za\nblogspot.cv\nblogspot.cz\nblogspot.de\nblogspot.dk\nblogspot.fi\nblogspot.fr\nblogspot.gr\nblogspot.hk\nblogspot.hr\nblogspot.hu\nblogspot.ie\nblogspot.in\nblogspot.is\nblogspot.it\nblogspot.jp\nblogspot.kr\nblogspot.li\nblogspot.lt\nblogspot.lu\nblogspot.md\nblogspot.mk\nblogspot.mr\nblogspot.mx\nblogspot.my\nblogspot.nl\nblogspot.no\nblogspot.pe\nblogspot.pt\nblogspot.qa\nblogspot.re\nblogspot.ro\nblogspot.rs\nblogspot.ru\nblogspot.se\nblogspot.sg\nblogspot.si\nblogspot.sk\nblogspot.sn\nblogspot.td\nblogspot.tw\nblogspot.ug\nblogspot.vn\n"
    printf "google.ac\ngoogle.ad\ngoogle.ae\ngoogle.al\ngoogle.am\ngoogle.as\ngoogle.at\ngoogle.az\ngoogle.ba\ngoogle.be\ngoogle.bf\ngoogle.bg\ngoogle.bi\ngoogle.bj\ngoogle.bs\ngoogle.bt\ngoogle.by\ngoogle.ca\ngoogle.cat\ngoogle.cc\ngoogle.cd\ngoogle.cf\ngoogle.cg\ngoogle.ch\ngoogle.ci\ngoogle.cl\ngoogle.cm\ngoogle.cn\ngoogle.co.ao\ngoogle.co.bw\ngoogle.co.ck\ngoogle.co.cr\ngoogle.co.id\ngoogle.co.il\ngoogle.co.in\ngoogle.co.jp\ngoogle.co.ke\ngoogle.co.kr\ngoogle.co.ls\ngoogle.com\ngoogle.co.ma\ngoogle.com.af\ngoogle.com.ag\ngoogle.com.ai\ngoogle.com.ar\ngoogle.com.au\ngoogle.com.bd\ngoogle.com.bh\ngoogle.com.bn\ngoogle.com.bo\ngoogle.com.br\ngoogle.com.bz\ngoogle.com.co\ngoogle.com.cu\ngoogle.com.cy\ngoogle.com.do\ngoogle.com.ec\ngoogle.com.eg\ngoogle.com.et\ngoogle.com.fj\ngoogle.com.gh\ngoogle.com.gi\ngoogle.com.gt\ngoogle.com.hk\ngoogle.com.jm\ngoogle.com.kh\ngoogle.com.kw\ngoogle.com.lb\ngoogle.com.lc\ngoogle.com.ly\ngoogle.com.mm\ngoogle.com.mt\ngoogle.com.mx\ngoogle.com.my\ngoogle.com.na\ngoogle.com.nf\ngoogle.com.ng\ngoogle.com.ni\ngoogle.com.np\ngoogle.com.om\ngoogle.com.pa\ngoogle.com.pe\ngoogle.com.pg\ngoogle.com.ph\ngoogle.com.pk\ngoogle.com.pr\ngoogle.com.py\ngoogle.com.qa\ngoogle.com.sa\ngoogle.com.sb\ngoogle.com.sg\ngoogle.com.sl\ngoogle.com.sv\ngoogle.com.tj\ngoogle.com.tr\ngoogle.com.tw\ngoogle.com.ua\ngoogle.com.uy\ngoogle.com.vc\ngoogle.com.vn\ngoogle.co.mz\ngoogle.co.nz\ngoogle.co.th\ngoogle.co.tz\ngoogle.co.ug\ngoogle.co.uk\ngoogle.co.uz\ngoogle.co.ve\ngoogle.co.vi\ngoogle.co.za\ngoogle.co.zm\ngoogle.co.zw\ngoogle.cv\ngoogle.cz\ngoogle.de\ngoogle.dj\ngoogle.dk\ngoogle.dm\ngoogle.dz\ngoogle.ee\ngoogle.es\ngoogle.fi\ngoogle.fm\ngoogle.fr\ngoogle.ga\ngoogle.ge\ngoogle.gf\ngoogle.gg\ngoogle.gl\ngoogle.gm\ngoogle.gp\ngoogle.gr\ngoogle.gy\ngoogle.hn\ngoogle.hr\ngoogle.ht\ngoogle.hu\ngoogle.ie\ngoogle.im\ngoogle.io\ngoogle.iq\ngoogle.is\ngoogle.it\ngoogle.je\ngoogle.jo\ngoogle.kg\ngoogle.ki\ngoogle.kz\ngoogle.la\ngoogle.li\ngoogle.lk\ngoogle.lt\ngoogle.lu\ngoogle.lv\ngoogle.md\ngoogle.me\ngoogle.mg\ngoogle.mk\ngoogle.ml\ngoogle.mn\ngoogle.ms\ngoogle.mu\ngoogle.mv\ngoogle.mw\ngoogle.ne\ngoogle.net\ngoogle.nl\ngoogle.no\ngoogle.nr\ngoogle.nu\ngoogle.org\ngoogle.pl\ngoogle.pn\ngoogle.ps\ngoogle.pt\ngoogle.ro\ngoogle.rs\ngoogle.ru\ngoogle.rw\ngoogle.sc\ngoogle.se\ngoogle.sh\ngoogle.si\ngoogle.sk\ngoogle.sm\ngoogle.sn\ngoogle.so\ngoogle.sr\ngoogle.st\ngoogle.td\ngoogle.tg\ngoogle.tk\ngoogle.tl\ngoogle.tm\ngoogle.tn\ngoogle.to\ngoogle.tt\ngoogle.vg\ngoogle.vu\ngoogle.ws\n"
}

font_bold() {
    printf "\e[1m$*\e[0m"
}

color_red() {
    printf "\e[35m$*\e[0m"
}

color_yellow() {
    printf "\e[31m$*\e[0m"
}

log_warn() {
    echo "$(font_bold $(color_red '[WARN]')) $*" 1>&2
}

log_error() {
    echo "$(font_bold $(color_yellow '[ERROR]')) $*" 1>&2
    exit 1
}

ignore() {
    true
}

is_true() {
    [ "$1" = 'true' ]
}

is_false() {
    [ "$1" = 'false' ]
}

file_is_exists() {
    [ -f "$1" ]
}

command_is_exists() {
    command -v "$1" &>/dev/null
}

process_is_running() {
    kill -0 "$1" &>/dev/null
}

sstproxy_is_started() {
    if is_true "$ipv4"; then
        iptables -t mangle -nL SSTP_OUTPUT &>/dev/null
        return $?
    else
        ip6tables -t mangle -nL SSTP_OUTPUT &>/dev/null
        return $?
    fi
}

is_ipv4_address() {
    [ $(grep -Ec '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' <<<"$1") -ne 0 ]
}

is_ipv6_address() {
    [ $(grep -c ':' <<<"$1") -ne 0 ]
}

is_domain_name() {
    ! is_ipv4_address "$1" && ! is_ipv6_address "$1"
}

resolve_hostname() {
    local ipaddr=""
    while [ -z "$ipaddr" ]; do
        ipaddr=$(ping -nq -c1 -t1 -W1 "$1" | head -n1 | gawk -F'[()]' '{print $2}') || ignore
    done
    echo "$ipaddr"
}

waiting_network() {
    until ping -nq -c1 -W1 "$1" &>/dev/null; do true; done
}

load_config() {
    file_is_exists "$ss_tproxy_config"   || log_error "file not found: $ss_tproxy_config"
    source "$ss_tproxy_config" || log_error "failed to load the conf file, exit-code: $?"
    file_is_exists "$file_gfwlist_txt"   || log_error "file not found: $file_gfwlist_txt"
    file_is_exists "$file_gfwlist_ext"   || log_error "file not found: $file_gfwlist_ext"
    file_is_exists "$file_chnroute_set"  || log_error "file not found: $file_chnroute_set"
    file_is_exists "$file_chnroute6_set" || log_error "file not found: $file_chnroute6_set"

    if sstproxy_is_started; then
        source "$file_dnsserver_pid" || log_error "failed to load the pid file, exit-code: $?"
    else
        rm -f "$file_dnsserver_pid" &>/dev/null || ignore
    fi

    case "$opts_ss_netstat" in
        auto)
            if command_is_exists 'ss'; then
                netstat='ss'
            elif command_is_exists 'netstat'; then
                netstat='netstat'
            else
                log_error "command not found: ss/netstat"
            fi
            ;;
        ss)
            command_is_exists 'ss' && netstat='ss' || log_error "command not found: ss"
            ;;
        netstat)
            command_is_exists 'netstat' && netstat='netstat' || log_error "command not found: netstat"
            ;;
        *)
            log_error "opts_ss_netstat option value is invalid: $opts_ss_netstat"
            ;;
    esac

    { is_false "$ipv4" && is_false "$ipv6"; } && log_error "both ipv4 and ipv6 are disabled, nothing to do"

    proxy_svraddr4=()
    proxy_svraddr6=()

    for svr in "${proxy_svraddr[@]}"; do
        local svr_ip=$(resolve_hostname "$svr")
        if is_ipv4_address "$svr_ip"; then
            proxy_svraddr4+=($svr_ip)
        else
            proxy_svraddr6+=($svr_ip)
        fi
    done

    { is_true "$ipv4" && [ "${#proxy_svraddr4[@]}" -eq 0 ]; } && log_error "not found ipv4 address in the proxy_svraddr"
    { is_true "$ipv6" && [ "${#proxy_svraddr6[@]}" -eq 0 ]; } && log_error "not found ipv6 address in the proxy_svraddr"

    { is_false "$ipv6" && [ "${#proxy_svraddr6[@]}" -ne 0 ]; } && log_warn "found ipv6 address(${proxy_svraddr6[@]}) in the proxy_svraddr, but ipv6 is disabled"
    { is_false "$ipv4" && [ "${#proxy_svraddr4[@]}" -ne 0 ]; } && log_warn "found ipv4 address(${proxy_svraddr4[@]}) in the proxy_svraddr, but ipv4 is disabled"
}

check_depend() {
    command_is_exists 'curl'     || log_warn  "command not found: curl"
    command_is_exists 'ip'       || log_error "command not found: ip"
    command_is_exists 'ipset'    || log_error "command not found: ipset"
    command_is_exists 'dnsmasq'  || log_error "command not found: dnsmasq"

    is_true "$ipv4" && { command_is_exists 'iptables'  || log_error "command not found: iptables";  }
    is_true "$ipv6" && { command_is_exists 'ip6tables' || log_error "command not found: ip6tables"; }

    case "$mode" in
        gfwlist)
            command_is_exists 'perl'   || log_warn  "command not found: perl"
            command_is_exists 'base64' || log_warn  "command not found: base64"
            ;;
        chnroute)
            command_is_exists "chinadns-ng" || log_error "command not found: chinadns-ng"
            ;;
    esac
}

update_chnonly() {
    local url='https://raw.github.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"
    echo "$data" | gawk -F/ '{print $2}' >$file_gfwlist_txt
}

update_gfwlist() {
    local url='https://raw.github.com/gfwlist/gfwlist/master/gfwlist.txt'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"

    local base64_decode=''
    base64 -d       </dev/null &>/dev/null && base64_decode='base64 -d'
    base64 --decode </dev/null &>/dev/null && base64_decode='base64 --decode'
    [ "$base64_decode" ] || log_error "command args is not support: base64 -d/--decode"

    echo "$data" | $base64_decode | { perl -pe "$gfwlist_txt_perl_script_string"; gfwlist_txt_append_domain_names; } | sort | uniq >$file_gfwlist_txt
}

update_chnroute() {
    local url='http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'
    local data; data=$(curl -4sSkL "$url") || log_error "download failed, exit-code: $?"
    {
        echo "create chnroute hash:net family inet"
        for reserved_ipaddr in "${ipv4_reserved_ipaddrs[@]}"; do echo "add chnroute $reserved_ipaddr"; done
        echo "$data" | grep CN | grep ipv4 | gawk -F'|' '{printf("add chnroute %s/%d\n", $4, 32-log($5)/log(2))}'
    } >$file_chnroute_set
    {
        echo "create chnroute6 hash:net family inet6"
        for reserved_ipaddr in "${ipv6_reserved_ipaddrs[@]}"; do echo "add chnroute6 $reserved_ipaddr"; done
        echo "$data" | grep CN | grep ipv6 | gawk -F'|' '{printf("add chnroute6 %s/%d\n", $4, $5)}'
    } >$file_chnroute6_set
}

flush_dnscache() {
    sstproxy_is_started && kill -HUP "$status_dnsmasq_pid"
}

flush_gfwlist() {
    is_true "$ipv4" && ipset -F gfwlist  &>/dev/null || ignore
    is_true "$ipv6" && ipset -F gfwlist6 &>/dev/null || ignore
}

_flush_iptables() {
    $1 -t mangle -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t mangle -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t nat    -D PREROUTING  -j SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t nat    -D OUTPUT      -j SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t nat    -D POSTROUTING -j SSTP_POSTROUTING &>/dev/null || ignore

    $1 -t mangle -F SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t mangle -X SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t mangle -F SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t mangle -X SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t nat    -F SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t nat    -X SSTP_PREROUTING  &>/dev/null || ignore
    $1 -t nat    -F SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t nat    -X SSTP_OUTPUT      &>/dev/null || ignore
    $1 -t nat    -F SSTP_POSTROUTING &>/dev/null || ignore
    $1 -t nat    -X SSTP_POSTROUTING &>/dev/null || ignore

    $1 -t mangle -F SSTP_RULE &>/dev/null || ignore
    $1 -t mangle -X SSTP_RULE &>/dev/null || ignore
    $1 -t nat    -F SSTP_RULE &>/dev/null || ignore
    $1 -t nat    -X SSTP_RULE &>/dev/null || ignore
}

flush_iptables() {
    is_true "$ipv4" && _flush_iptables "iptables"
    is_true "$ipv6" && _flush_iptables "ip6tables"
}

_show_iptables() {
    printf "\e[36;1m==> $1-mangle <==\e[0m\n"
    $1 -t mangle -nvL --line-numbers
    echo
    printf "\e[36;1m==> $1-nat <==\e[0m\n"
    $1 -t nat -nvL --line-numbers
}

show_iptables() {
    is_true "$ipv4" && _show_iptables "iptables"
    { is_true "$ipv4" && is_true "$ipv6"; } && echo
    is_true "$ipv6" && _show_iptables "ip6tables"
}

start_dnsserver_gfwlist() {
    local dnsmasq_config_string=$(cat <<EOF
$(is_true "$dnsmasq_log_enable" && echo 'log-queries')
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$([ $(dnsmasq --help | grep -c min-cache-ttl) -ne 0 ] && echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = $dnsmasq_bind_port
$(is_true "$ipv4" && echo "server = $dns_direct")
$(is_true "$ipv6" && echo "server = $dns_direct6")
$(
{ cat $file_gfwlist_txt; grep -E '^@' $file_gfwlist_ext | cut -c2-; } | while read domain_name; do
  is_true "$ipv4" && echo "server = /$domain_name/$dns_remote"
  is_true "$ipv6" && echo "server = /$domain_name/$dns_remote6"
  echo "ipset = /$domain_name/gfwlist,gfwlist6"
done
)
$(for append_config in "${dnsmasq_append_config[@]}"; do echo "$append_config"; done)
$([ "$dnsmasq_conf_dir" ] && echo "conf-dir = $dnsmasq_conf_dir")
EOF
)
    status_dnsmasq_pid=$(dnsmasq --no-daemon --conf-file=<(echo "$dnsmasq_config_string") </dev/null &>>$dnsmasq_log_file & echo $!)
}

start_dnsserver_chnroute() {
    local chinadns_args="-b 127.0.0.1 -l $chinadns_bind_port"
    is_true "$chinadns_verbose" && chinadns_args+=" -v"
    if is_true "$ipv4" && is_true "$ipv6"; then
        chinadns_args+=" -c $dns_direct,$dns_direct6"
        chinadns_args+=" -t $dns_remote,$dns_remote6"
    elif is_true "$ipv4"; then
        chinadns_args+=" -c $dns_direct"
        chinadns_args+=" -t $dns_remote"
    else
        chinadns_args+=" -c $dns_direct6"
        chinadns_args+=" -t $dns_remote6"
    fi
    status_chinadns_pid=$(chinadns-ng $chinadns_args </dev/null &>>$chinadns_logfile & echo $!)

    local dnsmasq_config_string=$(cat <<EOF
$(is_true "$dnsmasq_log_enable" && echo 'log-queries')
log-async = 20
domain-needed
cache-size = $dnsmasq_cache_size
$([ $(dnsmasq --help | grep -c min-cache-ttl) -ne 0 ] && echo "min-cache-ttl = $dnsmasq_cache_time")
no-negcache
no-resolv
port = $dnsmasq_bind_port
server = 127.0.0.1#$chinadns_bind_port
$(for append_config in "${dnsmasq_append_config[@]}"; do echo "$append_config"; done)
$([ "$dnsmasq_conf_dir" ] && echo "conf-dir = $dnsmasq_conf_dir")
EOF
)
    status_dnsmasq_pid=$(dnsmasq --no-daemon --conf-file=<(echo "$dnsmasq_config_string") </dev/null &>>$dnsmasq_log_file & echo $!)
}

start_dnsserver() {
    local dnsmasq_append_config=()
    for svr in "${proxy_svraddr[@]}"; do
        if is_domain_name "$svr"; then
            local svr_ip=$(resolve_hostname "$svr")
            dnsmasq_append_config+=("address = /$svr/$svr_ip")
        fi
    done
    case "$mode" in
        gfwlist)
            start_dnsserver_gfwlist
            ;;
        chnroute)
            start_dnsserver_chnroute
            ;;
    esac
}

modify_resolvconf() {
    if is_false "$opts_overwrite_resolv"; then
        while umount /etc/resolv.conf &>/dev/null; do true; done
        temp_resolv_conf=$(mktemp)
        chmod 0644 $temp_resolv_conf
        mount -o bind $temp_resolv_conf /etc/resolv.conf
        rm -f $temp_resolv_conf
    fi
    echo "# Generated by ss-tproxy at $(date '+%F %T')" >/etc/resolv.conf
    echo "nameserver 127.0.0.1" >>/etc/resolv.conf
}

restore_resolvconf() {
    if is_false "$opts_overwrite_resolv"; then
        while umount /etc/resolv.conf &>/dev/null; do true; done
    else
        echo "# Generated by ss-tproxy at $(date '+%F %T')" >/etc/resolv.conf
        is_true "$ipv4" && echo "nameserver $dns_direct" >>/etc/resolv.conf
        is_true "$ipv6" && echo "nameserver $dns_direct6" >>/etc/resolv.conf
    fi
}

start_proxy_proc() {
    eval "$proxy_startcmd" || log_error "failed to start local proxy process, exit-code: $?"
}

stop_proxy_proc() {
    eval "$proxy_stopcmd" || ignore
}

enable_ipforward() {
    is_true "$ipv4" && sysctl -w net.ipv4.ip_forward=1 &>/dev/null
    is_true "$ipv6" && sysctl -w net.ipv6.conf.all.forwarding=1 &>/dev/null
}

disable_icmpredir() {
    is_false "$ipv4" && return
    for dir in $(ls /proc/sys/net/ipv4/conf); do
        sysctl -w net.ipv4.conf.$dir.send_redirects=0 &>/dev/null
    done
}

is_ipv4_ipts() {
    [ "$1" = 'iptables' ]
}

start_iptables_pre_rules() {
    $1 -t mangle -N SSTP_PREROUTING
    $1 -t mangle -N SSTP_OUTPUT
    $1 -t nat    -N SSTP_PREROUTING
    $1 -t nat    -N SSTP_OUTPUT
    $1 -t nat    -N SSTP_POSTROUTING

    local iproute2_family iproute2_default_rt
    is_ipv4_ipts $1 && iproute2_family="-4" || iproute2_family="-6"
    is_ipv4_ipts $1 && iproute2_default_rt="0/0" || iproute2_default_rt="::/0"

    ip $iproute2_family route add local $iproute2_default_rt dev lo table $ipts_rt_tab
    ip $iproute2_family rule  add fwmark $ipts_rt_mark              table $ipts_rt_tab
}

start_iptables_post_rules() {
    $1 -t mangle -A PREROUTING  -j SSTP_PREROUTING
    $1 -t mangle -A OUTPUT      -j SSTP_OUTPUT
    $1 -t nat    -A PREROUTING  -j SSTP_PREROUTING
    $1 -t nat    -A OUTPUT      -j SSTP_OUTPUT
    $1 -t nat    -A POSTROUTING -j SSTP_POSTROUTING
}

start_iptables_tproxy_common() {
    # TODO
    return 0
}

start_iptables_tproxy_gfwlist() {
    local gfwlist_setname
    is_ipv4_ipts $1 && gfwlist_setname="gfwlist" || gfwlist_setname="gfwlist6"

    local gfwlist_setfamily
    is_ipv4_ipts $1 && gfwlist_setfamily="inet" || gfwlist_setfamily="inet6"

    local grep_pattern
    is_ipv4_ipts $1 && grep_pattern="^-" || grep_pattern="^~"

    local svr_ip_array
    is_ipv4_ipts $1 && svr_ip_array=("${proxy_svraddr4[@]}") || svr_ip_array=("${proxy_svraddr6[@]}")

    ipset -N $gfwlist_setname hash:net family $gfwlist_setfamily &>/dev/null || ignore
    grep -E "$grep_pattern" $file_gfwlist_ext | cut -c2- | while read ip_addr; do echo "-A $gfwlist_setname $ip_addr"; done | ipset -R &>/dev/null || ignore
    for svr_ip in "${svr_ip_array[@]}"; do echo "-A $gfwlist_setname $svr_ip"; done | ipset -R &>/dev/null || ignore

    $1 -t mangle -N SSTP_RULE

    for svr_ip in "${svr_ip_array[@]}"; do
        $1 -t mangle -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
        $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
    done

    local direct_dns_ip
    is_ipv4_ipts $1 && direct_dns_ip="$dns_direct" || direct_dns_ip="$dns_direct6"
    $1 -t mangle -A SSTP_RULE -p udp -d $direct_dns_ip --dport 53 -j RETURN

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts $1 && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts $1 && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"
    $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark

    $1 -t mangle -A SSTP_RULE -p tcp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -j MARK --set-mark $ipts_rt_mark
    $1 -t mangle -A SSTP_RULE -p udp -m set --match-set $gfwlist_setname dst -m multiport --dports $ipts_proxy_dst_port -j MARK --set-mark $ipts_rt_mark

    start_iptables_tproxy_common $1
}

start_iptables_tproxy_chnroute() {
    local chnroute_setname chnroute_setfile
    is_ipv4_ipts $1 && chnroute_setname="chnroute" || chnroute_setname="chnroute6"
    is_ipv4_ipts $1 && chnroute_setfile="$file_chnroute_set" || chnroute_setfile="$file_chnroute6_set"
    ipset -X $chnroute_setname &>/dev/null || ignore
    ipset -R <$chnroute_setfile

    local intranet_array
    is_ipv4_ipts $1 && intranet_array=("${ipts_intranet[@]}") || intranet_array=("${ipts_intranet6[@]}")
    for intranet in "${intranet_array[@]}"; do echo "-A $chnroute_setname $intranet"; done | ipset -R &>/dev/null || ignore

    local direct_dns
    is_ipv4_ipts $1 && direct_dns="$dns_direct" || direct_dns="$dns_direct6"
    ipset -A $chnroute_setname $direct_dns &>/dev/null || ignore

    $1 -t mangle -N SSTP_RULE

    local svr_ip_array
    is_ipv4_ipts $1 && svr_ip_array=("${proxy_svraddr4[@]}") || svr_ip_array=("${proxy_svraddr6[@]}")
    for svr_ip in "${svr_ip_array[@]}"; do
        $1 -t mangle -A SSTP_RULE -p tcp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
        $1 -t mangle -A SSTP_RULE -p udp -d $svr_ip -m multiport --dports $proxy_svrport -j RETURN
    done

    local remote_dns_ip remote_dns_port
    is_ipv4_ipts $1 && remote_dns_ip="${dns_remote%%#*}" || remote_dns_ip="${dns_remote6%%#*}"
    is_ipv4_ipts $1 && remote_dns_port="${dns_remote##*#}" || remote_dns_port="${dns_remote6##*#}"
    $1 -t mangle -A SSTP_RULE -p udp -d $remote_dns_ip --dport $remote_dns_port -j MARK --set-mark $ipts_rt_mark

    $1 -t mangle -A SSTP_RULE -m set --match-set $chnroute_setname dst -j RETURN

    $1 -t mangle -A SSTP_RULE -p tcp -m multiport --dports $ipts_proxy_dst_port -j MARK --set-mark $ipts_rt_mark
    $1 -t mangle -A SSTP_RULE -p udp -m multiport --dports $ipts_proxy_dst_port -j MARK --set-mark $ipts_rt_mark

    start_iptables_tproxy_common $1
}

start_iptables_redirect_common() {
    # TODO
    return 0
}

start_iptables_redirect_gfwlist() {
    # TODO
    return 0
}

start_iptables_redirect_chnroute() {
    # TODO
    return 0
}

start_iptables() {
    is_true "$ipv4" && start_iptables_pre_rules "iptables"
    is_true "$ipv6" && start_iptables_pre_rules "ip6tables"

    case "$mode" in
        gfwlist)
            is_true "$ipv4" && { is_true "$tproxy" && start_iptables_tproxy_gfwlist "iptables"  || start_iptables_redirect_gfwlist "iptables";  }
            is_true "$ipv6" && { is_true "$tproxy" && start_iptables_tproxy_gfwlist "ip6tables" || start_iptables_redirect_gfwlist "ip6tables"; }
            ;;
        chnroute)
            is_true "$ipv4" && { is_true "$tproxy" && start_iptables_tproxy_chnroute "iptables"  || start_iptables_redirect_chnroute "iptables";  }
            is_true "$ipv6" && { is_true "$tproxy" && start_iptables_tproxy_chnroute "ip6tables" || start_iptables_redirect_chnroute "ip6tables"; }
            ;;
    esac

    is_true "$ipv4" && start_iptables_post_rules "iptables"
    is_true "$ipv6" && start_iptables_post_rules "ip6tables"
}

start() {
    # TODO
    return 0
}

stop() {
    # TODO
    return 0
}

status() {
    # TODO
    return 0
}

help() {
    # TODO
    return 0
}

main() {
    # TODO
    return 0
}
main "$@"
