## mode
#mode='global'  # 全局：{ignlist}走直连，其他走代理
#mode='gfwlist' # 黑名单：{gfwlist}走代理，其他走直连 (回国模式也是这个，见readme)
mode='chnroute' # 大陆白名单：{gfwlist}走代理，{ignlist,chnlist,chnroute}走直连，其他走代理

## ipv4/6
ipv4='true'     # 是否对ipv4启用'透明代理': true启用 false不启用
ipv6='false'    # 是否对ipv6启用'透明代理': true启用 false不启用

## tproxy
tproxy='false'  # true: TPROXY(tcp) + TPROXY(udp) ##纯tproxy模式##
                # false: REDIRECT(tcp) + TPROXY(udp) ##redirect模式##
                #
                # 具体取决于'本机代理进程'的透明代理传入'协议'
                #
                # ss/ssr/trojan 通常为 redirect模式
                # v2ray 两者都支持，具体取决于v2ray配置
                # ipt2socks 默认为 纯tproxy模式，也可切换为 redirect模式
                # ss-libev 3.3.5+ 支持 纯tproxy模式，参数为"-T"、"tcp_tproxy": true
                #
                # 其他代理软件请自行甄别测试，配置错误会导致透明代理跑不通

## tcponly
tcponly='false' # true:仅代理TCP流量; false:代理TCP和UDP流量
                # 这个也取决与'代理套件'，有些代理不支持UDP协议

## selfonly
selfonly='false' # true: 只代理ss-tproxy主机(本机)传出的流量
                 # false: 代理本机、内网机传出的流量(网关和dns指向ss-tproxy主机)
                 # 由于dns_remote必须走代理，且dns逻辑在本机进行，因此本机必须走代理
                 # 虽然可以只处理dns流量，其他流量不走代理，但感觉意义不大，还是简单点好

## proxy
#
# 本机代理进程相关，如透明代理端口，进程启动和停止命令(如果想自己控制进程启停，可填true)
#
# ss-tproxy要求"代理进程"不参与ip分流，也不参与dns解析，专心让iptables过来的tcp/udp流量走代理即可
# 本机代理进程只会收到"纯ip"的tcp/udp流量，不会有dns相关的东西让你知晓，因为这些已被dns解析组件处理
# 因此ss-tproxy的设计原则是：各组件只负责自己的专业领域，无需知晓透明代理的全局面貌，做好自己的事就行
#
# 关于节点切换，不建议ss-tproxy restart，因为这是一个重量级操作，没必要反复操作iptables
# 除非tproxy模式、tcponly模式等涉及到iptables的配置发生了更改，否则建议只重启代理进程本身
# 换句话说，ss-tproxy应该主要用于iptables管理，以及附带的dns方案，顺便帮你启动/关闭代理进程
#
proxy_procgroup='proxy'  # 本机代理进程的group(fsgid)，所有代理进程都需要以此身份运行，用于流量放行
proxy_tcpport='60080'    # ss/ssr/v2ray/ipt2socks 等本机进程的 TCP 监听端口，该端口支持"透明代理"
proxy_udpport='60080'    # ss/ssr/v2ray/ipt2socks 等本机进程的 UDP 监听端口，该端口支持"透明代理"
                         # 代理进程只需监听"127.0.0.1"(v4环境)+"::1"(v6环境)，不必监听"0.0.0.0"
proxy_startcmd='cmd'     # 用于启动本机代理进程(组)的 shell 命令行，该命令行不应该执行过长时间
proxy_stopcmd='cmd'      # 用于关闭本机代理进程(组)的 shell 命令行，该命令行不应该执行过长时间

## dns
dns_custom='false'                    # true:使用自定义dns方案(高级用户,见下面的说明) | false:使用内置dns方案
                                      # 使用自定义dns方案时，dnsmasq和chinadns相关配置被忽略，其他dns配置不受影响
                                      # 由于dnsmasq/chinadns-ng不会启动，因此内置dns分流规则将失效，你需要自己处理它
                                      # 当udp代理未启用时(tcponly)，自定义dns方案必须通过tcp访问dns_remote，见dns2tcp
dns_procgroup='proxy_dns'             # dns进程的group(fsgid)，不能与proxy_procgroup相同，所有dns进程都需要以此身份运行
dns_mainport='53'                     # dns请求的逻辑入口(udp监听端口)，脚本内部会将"所有"dns请求重定向至此udp端口
                                      # dns入口进程必须监听"127.0.0.1"(v4环境)+"::1"(v6环境)，用于接收本机dns请求
                                      # 如果要代理内网，则监听地址还需覆盖到相关网卡，为了简单，建议监听通配地址(全0)
dns_direct='223.5.5.5#53'             # 直连DNS(v4环境使用)，必须指定端口，该ip会被加入白名单(global/chnroute)
dns_direct6='240C::6666#53'           # 直连DNS(v6环境使用)，必须指定端口，该ip会被加入白名单(global/chnroute)
dns_remote='8.8.8.8#53'               # 远程DNS(v4环境使用)，必须指定端口，该ip会被加入黑名单(gfwlist/chnroute)
dns_remote6='2001:4860:4860::8888#53' # 远程DNS(v6环境使用)，必须指定端口，该ip会被加入黑名单(gfwlist/chnroute)

## dnsmasq
# 使用自定义dns方案时，dnsmasq相关配置被忽略，dnsmasq不会启动
dnsmasq_cache_size='4096'               # DNS 缓存大小，大小为 0 表示禁用缓存
dnsmasq_cache_time='3600'               # DNS 缓存时间，单位是秒，最大 3600 秒
dnsmasq_query_maxcnt='1024'             # 设置并发 DNS 查询的最大数量，默认为 150
dnsmasq_log_enable='false'              # 记录详细日志，除非进行调试，否则不建议启用
dnsmasq_log_file='/var/log/dnsmasq.log' # 日志文件，如果不想保存日志可以改为 /dev/null
dnsmasq_conf_dir=()                     # `--conf-dir` 选项的参数，可以填多个，空格隔开
dnsmasq_conf_file=()                    # `--conf-file` 选项的参数，可以填多个，空格隔开
dnsmasq_conf_string=()                  # 自定义配置，一个数组元素就是一行配置，空格隔开

## chinadns
# 使用自定义dns方案时，chinadns-ng相关配置被忽略，chinadns-ng不会启动
chinadns_bind_port='65353'               # 监听端口，若 65353 被占用，请注意更改
chinadns_chnlist_first='false'           # 优先加载 chnlist 域名 (默认优先 gfwlist)
chinadns_extra_options=''                # 其他附加的命令行选项(已有的选项就别再填了)
chinadns_verbose='false'                 # 记录详细日志，除非进行调试，否则不建议启用
chinadns_logfile='/var/log/chinadns.log' # 日志文件，如果不想保存日志可以改为 /dev/null

## dns2tcp
# 内部会使用iptables规则将发往dns_remote的udp包重定向到dns2tcp监听端口，对其他组件透明
dns2tcp_enable='auto'                   # auto:tcponly时启用 | true:总是启用 | false:禁用(自定义dns时)
dns2tcp_bind_port='65454'               # 监听端口，若 65454 被占用，请注意更改
dns2tcp_extra_options=''                # 其他附加的命令行选项(已有的选项就别再填了)
dns2tcp_verbose='false'                 # 记录详细日志，除非进行调试，否则不建议启用
dns2tcp_logfile='/var/log/dns2tcp.log'  # 日志文件，如果不想保存日志可以改为 /dev/null

## ipts
ipts_if_lo='lo'             # 环回接口的名称，在标准发行版中，通常为 lo，如果不是请修改
ipts_rt_tab='233'           # iproute2 路由表名或表 ID，除非产生冲突，否则不建议改动该选项
ipts_rt_mark='0x2333'       # iproute2 策略路由的防火墙标记，除非产生冲突，否则不建议改动该选项
ipts_set_snat='false'       # 设置 ipv4 MASQUERADE(SNAT) 规则，selfonly=false 时有效，详见 README
ipts_set_snat6='false'      # 设置 ipv6 MASQUERADE(SNAT) 规则，selfonly=false 时有效，详见 README
ipts_reddns_onstop='true'   # stop后重定向内网主机发来的dns至直连dns，selfonly=false 时有效，详见 README
ipts_proxy_dst_port=''      # 要代理哪些端口，留空表示全部，多个逗号隔开，冒号表示范围(含边界)，详见 README

## opts
opts_ss_netstat='auto'      # auto/ss/netstat，用哪个端口检测工具: auto(自动选择,优先考虑ss) | ss | netstat

## url
# 用于更新gfwlist.txt，格式：`域名后缀`或`server=/域名后缀/dns_ip`(dnsmasq格式，只关心`域名后缀`字段)
url_gfwlist='https://raw.githubusercontent.com/pexcn/daily/gh-pages/gfwlist/gfwlist.txt'
# 用于更新chnlist.txt，格式：`域名后缀`或`server=/域名后缀/dns_ip`(dnsmasq格式，只关心`域名后缀`字段)
url_chnlist='https://raw.github.com/felixonmars/dnsmasq-china-list/master/accelerated-domains.china.conf'
# 用于更新chnroute*.set，改之前先确认格式是否同apnic，或者自己更新相关文件，不借助ss-tproxy
url_chnroute='http://ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest'

# 此函数在"启动逻辑之前"执行
pre_start() {
    # do something
    return
}

# 此函数在"启动逻辑之后"执行
post_start() {
    # do something
    return
}

# 此函数在"停止逻辑之前"执行
pre_stop() {
    # do something
    return
}

# 此函数在"停止逻辑之后"执行
post_stop() {
    # do something
    return
}

# 额外状态，如自定义dns方案
extra_status() {
    # do something
    return
}

# 除了上述钩子函数，你还可以定义其他shell函数和变量
# 你也可以在当前文件使用ss-tproxy中已定义的函数和变量
#
# 若定义的函数与ss-tproxy中的同名，则本文件定义的函数覆盖原函数
# 使用自定义dns方案时，此特性可帮助你快速与原脚本融合(见脚本源码)
#
# ss-tproxy.conf是一个shell脚本，可以使用source来加载其他shell脚本
# ss-tproxy.conf被执行时，可以访问ss-tproxy传来的命令行参数(位置参数)
